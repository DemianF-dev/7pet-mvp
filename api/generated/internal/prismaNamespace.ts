
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the `model` directory!
 */

import * as runtime from "@prisma/client/runtime/client"
import type * as Prisma from "../models"
import { type PrismaClient } from "./class"

export type * from '../models'

export type DMMF = typeof runtime.DMMF

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

/**
 * Prisma Errors
 */

export const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
export type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError

export const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
export type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError

export const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError

export const PrismaClientInitializationError = runtime.PrismaClientInitializationError
export type PrismaClientInitializationError = runtime.PrismaClientInitializationError

export const PrismaClientValidationError = runtime.PrismaClientValidationError
export type PrismaClientValidationError = runtime.PrismaClientValidationError

/**
 * Re-export of sql-template-tag
 */
export const sql = runtime.sqltag
export const empty = runtime.empty
export const join = runtime.join
export const raw = runtime.raw
export const Sql = runtime.Sql
export type Sql = runtime.Sql



/**
 * Decimal.js
 */
export const Decimal = runtime.Decimal
export type Decimal = runtime.Decimal

export type DecimalJsLike = runtime.DecimalJsLike

/**
* Extensions
*/
export type Extension = runtime.Types.Extensions.UserArgs
export const getExtensionContext = runtime.Extensions.getExtensionContext
export type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>
export type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>
export type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>
export type Exact<A, W> = runtime.Types.Public.Exact<A, W>

export type PrismaVersion = {
  client: string
  engine: string
}

/**
 * Prisma Client JS version: 7.2.0
 * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3
 */
export const prismaVersion: PrismaVersion = {
  client: "7.2.0",
  engine: "0c8ef2ce45c83248ab3df073180d5eda9e8be7a3"
}

/**
 * Utility Types
 */

export type Bytes = runtime.Bytes
export type JsonObject = runtime.JsonObject
export type JsonArray = runtime.JsonArray
export type JsonValue = runtime.JsonValue
export type InputJsonObject = runtime.InputJsonObject
export type InputJsonArray = runtime.InputJsonArray
export type InputJsonValue = runtime.InputJsonValue


export const NullTypes = {
  DbNull: runtime.NullTypes.DbNull as (new (secret: never) => typeof runtime.DbNull),
  JsonNull: runtime.NullTypes.JsonNull as (new (secret: never) => typeof runtime.JsonNull),
  AnyNull: runtime.NullTypes.AnyNull as (new (secret: never) => typeof runtime.AnyNull),
}
/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.DbNull

/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.JsonNull

/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.AnyNull


type SelectAndInclude = {
  select: any
  include: any
}

type SelectAndOmit = {
  select: any
  omit: any
}

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};

export type Enumerable<T> = T | Array<T>;

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {})

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
export type SubsetIntersection<T, U, K> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  K

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
export type XOR<T, U> =
  T extends object ?
  U extends object ?
    (Without<T, U> & U) | (Without<U, T> & T)
  : U : T


/**
 * Is T a Record?
 */
type IsObject<T extends any> = T extends Array<any>
? False
: T extends Date
? False
: T extends Uint8Array
? False
: T extends BigInt
? False
: T extends object
? True
: False


/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
  {
    // Merge all but K
    [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
  }[K]

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

type _Either<
  O extends object,
  K extends Key,
  strict extends Boolean
> = {
  1: EitherStrict<O, K>
  0: EitherLoose<O, K>
}[strict]

export type Either<
  O extends object,
  K extends Key,
  strict extends Boolean = 1
> = O extends unknown ? _Either<O, K, strict> : never

export type Union = any

export type PatchUndefined<O extends object, O1 extends object> = {
  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
} & {}

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (
  U extends unknown ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never

export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<Overwrite<U, {
    [K in keyof U]-?: At<U, K>;
}>>;

type Key = string | number | symbol;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function ? A : {
  [K in keyof A]: A[K];
} & {};

export type OptionalFlat<O> = {
  [K in keyof O]?: O[K];
} & {};

type _Record<K extends keyof any, T> = {
  [P in K]: T;
};

// cause typescript not to expand types and preserve names
type NoExpand<T> = T extends unknown ? T : never;

// this type assumes the passed object is entirely optional
export type AtLeast<O extends object, K extends string> = NoExpand<
  O extends unknown
  ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
    | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
  : never>;

type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

export type Boolean = True | False

export type True = 1

export type False = 0

export type Not<B extends Boolean> = {
  0: 1
  1: 0
}[B]

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
  ? 0 // anything `never` is false
  : A1 extends A2
  ? 1
  : 0

export type Has<U extends Union, U1 extends Union> = Not<
  Extends<Exclude<U1, U>, U1>
>

export type Or<B1 extends Boolean, B2 extends Boolean> = {
  0: {
    0: 0
    1: 1
  }
  1: {
    0: 1
    1: 1
  }
}[B1][B2]

export type Keys<U extends Union> = U extends unknown ? keyof U : never

export type GetScalarType<T, O> = O extends object ? {
  [P in keyof T]: P extends keyof O
    ? O[P]
    : never
} : never

type FieldPaths<
  T,
  U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
> = IsObject<T> extends True ? U : T

export type GetHavingFields<T> = {
  [K in keyof T]: Or<
    Or<Extends<'OR', K>, Extends<'AND', K>>,
    Extends<'NOT', K>
  > extends True
    ? // infer is only needed to not hit TS limit
      // based on the brilliant idea of Pierre-Antoine Mills
      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
      T[K] extends infer TK
      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
      : never
    : {} extends FieldPaths<T[K]>
    ? never
    : K
}[keyof T]

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
export type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

/**
 * Like `Pick`, but additionally can also accept an array of keys
 */
export type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

/**
 * Exclude all keys with underscores
 */
export type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


export const ModelName = {
  Appointment: 'Appointment',
  Appreciation: 'Appreciation',
  AttendanceRecord: 'AttendanceRecord',
  AuditEvent: 'AuditEvent',
  AuditLog: 'AuditLog',
  Authenticator: 'Authenticator',
  BugReport: 'BugReport',
  Comment: 'Comment',
  Conversation: 'Conversation',
  Customer: 'Customer',
  CustomerAlert: 'CustomerAlert',
  DebitCreditNote: 'DebitCreditNote',
  FinancialTransaction: 'FinancialTransaction',
  Goal: 'Goal',
  GoalAssignment: 'GoalAssignment',
  HrAuditLog: 'HrAuditLog',
  Invoice: 'Invoice',
  Message: 'Message',
  Metric: 'Metric',
  Notification: 'Notification',
  NotificationExecution: 'NotificationExecution',
  NotificationSettings: 'NotificationSettings',
  PackageItem: 'PackageItem',
  Participant: 'Participant',
  PayAdjustment: 'PayAdjustment',
  PayPeriod: 'PayPeriod',
  PayStatement: 'PayStatement',
  PaymentRecord: 'PaymentRecord',
  Pet: 'Pet',
  Post: 'Post',
  Product: 'Product',
  PushSubscription: 'PushSubscription',
  Quote: 'Quote',
  QuoteItem: 'QuoteItem',
  Reaction: 'Reaction',
  RecurringPackage: 'RecurringPackage',
  RolePermission: 'RolePermission',
  ScheduledNotification: 'ScheduledNotification',
  Service: 'Service',
  ServiceExecution: 'ServiceExecution',
  StaffProfile: 'StaffProfile',
  StatusHistory: 'StatusHistory',
  TransportDetails: 'TransportDetails',
  TransportLegExecution: 'TransportLegExecution',
  TransportLeg: 'TransportLeg',
  RouteCache: 'RouteCache',
  TransportSettings: 'TransportSettings',
  User: 'User',
  UserNotificationPreference: 'UserNotificationPreference'
} as const

export type ModelName = (typeof ModelName)[keyof typeof ModelName]



export interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<{extArgs: runtime.Types.Extensions.InternalArgs }, runtime.Types.Utils.Record<string, any>> {
  returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>
}

export type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
  globalOmitOptions: {
    omit: GlobalOmitOptions
  }
  meta: {
    modelProps: "appointment" | "appreciation" | "attendanceRecord" | "auditEvent" | "auditLog" | "authenticator" | "bugReport" | "comment" | "conversation" | "customer" | "customerAlert" | "debitCreditNote" | "financialTransaction" | "goal" | "goalAssignment" | "hrAuditLog" | "invoice" | "message" | "metric" | "notification" | "notificationExecution" | "notificationSettings" | "packageItem" | "participant" | "payAdjustment" | "payPeriod" | "payStatement" | "paymentRecord" | "pet" | "post" | "product" | "pushSubscription" | "quote" | "quoteItem" | "reaction" | "recurringPackage" | "rolePermission" | "scheduledNotification" | "service" | "serviceExecution" | "staffProfile" | "statusHistory" | "transportDetails" | "transportLegExecution" | "transportLeg" | "routeCache" | "transportSettings" | "user" | "userNotificationPreference"
    txIsolationLevel: TransactionIsolationLevel
  }
  model: {
    Appointment: {
      payload: Prisma.$AppointmentPayload<ExtArgs>
      fields: Prisma.AppointmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AppointmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AppointmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>
        }
        findFirst: {
          args: Prisma.AppointmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AppointmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>
        }
        findMany: {
          args: Prisma.AppointmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
        }
        create: {
          args: Prisma.AppointmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>
        }
        createMany: {
          args: Prisma.AppointmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AppointmentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
        }
        delete: {
          args: Prisma.AppointmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>
        }
        update: {
          args: Prisma.AppointmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>
        }
        deleteMany: {
          args: Prisma.AppointmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AppointmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AppointmentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
        }
        upsert: {
          args: Prisma.AppointmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>
        }
        aggregate: {
          args: Prisma.AppointmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAppointment>
        }
        groupBy: {
          args: Prisma.AppointmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AppointmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.AppointmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AppointmentCountAggregateOutputType> | number
        }
      }
    }
    Appreciation: {
      payload: Prisma.$AppreciationPayload<ExtArgs>
      fields: Prisma.AppreciationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AppreciationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AppreciationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationPayload>
        }
        findFirst: {
          args: Prisma.AppreciationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AppreciationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationPayload>
        }
        findMany: {
          args: Prisma.AppreciationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationPayload>[]
        }
        create: {
          args: Prisma.AppreciationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationPayload>
        }
        createMany: {
          args: Prisma.AppreciationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AppreciationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationPayload>[]
        }
        delete: {
          args: Prisma.AppreciationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationPayload>
        }
        update: {
          args: Prisma.AppreciationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationPayload>
        }
        deleteMany: {
          args: Prisma.AppreciationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AppreciationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AppreciationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationPayload>[]
        }
        upsert: {
          args: Prisma.AppreciationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationPayload>
        }
        aggregate: {
          args: Prisma.AppreciationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAppreciation>
        }
        groupBy: {
          args: Prisma.AppreciationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AppreciationGroupByOutputType>[]
        }
        count: {
          args: Prisma.AppreciationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AppreciationCountAggregateOutputType> | number
        }
      }
    }
    AttendanceRecord: {
      payload: Prisma.$AttendanceRecordPayload<ExtArgs>
      fields: Prisma.AttendanceRecordFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AttendanceRecordFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendanceRecordPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AttendanceRecordFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
        }
        findFirst: {
          args: Prisma.AttendanceRecordFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendanceRecordPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AttendanceRecordFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
        }
        findMany: {
          args: Prisma.AttendanceRecordFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>[]
        }
        create: {
          args: Prisma.AttendanceRecordCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
        }
        createMany: {
          args: Prisma.AttendanceRecordCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AttendanceRecordCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>[]
        }
        delete: {
          args: Prisma.AttendanceRecordDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
        }
        update: {
          args: Prisma.AttendanceRecordUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
        }
        deleteMany: {
          args: Prisma.AttendanceRecordDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AttendanceRecordUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AttendanceRecordUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>[]
        }
        upsert: {
          args: Prisma.AttendanceRecordUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
        }
        aggregate: {
          args: Prisma.AttendanceRecordAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAttendanceRecord>
        }
        groupBy: {
          args: Prisma.AttendanceRecordGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AttendanceRecordGroupByOutputType>[]
        }
        count: {
          args: Prisma.AttendanceRecordCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AttendanceRecordCountAggregateOutputType> | number
        }
      }
    }
    AuditEvent: {
      payload: Prisma.$AuditEventPayload<ExtArgs>
      fields: Prisma.AuditEventFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AuditEventFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditEventPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AuditEventFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditEventPayload>
        }
        findFirst: {
          args: Prisma.AuditEventFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditEventPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AuditEventFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditEventPayload>
        }
        findMany: {
          args: Prisma.AuditEventFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditEventPayload>[]
        }
        create: {
          args: Prisma.AuditEventCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditEventPayload>
        }
        createMany: {
          args: Prisma.AuditEventCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AuditEventCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditEventPayload>[]
        }
        delete: {
          args: Prisma.AuditEventDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditEventPayload>
        }
        update: {
          args: Prisma.AuditEventUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditEventPayload>
        }
        deleteMany: {
          args: Prisma.AuditEventDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AuditEventUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AuditEventUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditEventPayload>[]
        }
        upsert: {
          args: Prisma.AuditEventUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditEventPayload>
        }
        aggregate: {
          args: Prisma.AuditEventAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAuditEvent>
        }
        groupBy: {
          args: Prisma.AuditEventGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AuditEventGroupByOutputType>[]
        }
        count: {
          args: Prisma.AuditEventCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AuditEventCountAggregateOutputType> | number
        }
      }
    }
    AuditLog: {
      payload: Prisma.$AuditLogPayload<ExtArgs>
      fields: Prisma.AuditLogFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        findFirst: {
          args: Prisma.AuditLogFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        findMany: {
          args: Prisma.AuditLogFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
        }
        create: {
          args: Prisma.AuditLogCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        createMany: {
          args: Prisma.AuditLogCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
        }
        delete: {
          args: Prisma.AuditLogDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        update: {
          args: Prisma.AuditLogUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        deleteMany: {
          args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
        }
        upsert: {
          args: Prisma.AuditLogUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        aggregate: {
          args: Prisma.AuditLogAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAuditLog>
        }
        groupBy: {
          args: Prisma.AuditLogGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AuditLogGroupByOutputType>[]
        }
        count: {
          args: Prisma.AuditLogCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AuditLogCountAggregateOutputType> | number
        }
      }
    }
    Authenticator: {
      payload: Prisma.$AuthenticatorPayload<ExtArgs>
      fields: Prisma.AuthenticatorFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AuthenticatorFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuthenticatorPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AuthenticatorFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuthenticatorPayload>
        }
        findFirst: {
          args: Prisma.AuthenticatorFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuthenticatorPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AuthenticatorFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuthenticatorPayload>
        }
        findMany: {
          args: Prisma.AuthenticatorFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuthenticatorPayload>[]
        }
        create: {
          args: Prisma.AuthenticatorCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuthenticatorPayload>
        }
        createMany: {
          args: Prisma.AuthenticatorCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AuthenticatorCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuthenticatorPayload>[]
        }
        delete: {
          args: Prisma.AuthenticatorDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuthenticatorPayload>
        }
        update: {
          args: Prisma.AuthenticatorUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuthenticatorPayload>
        }
        deleteMany: {
          args: Prisma.AuthenticatorDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AuthenticatorUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AuthenticatorUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuthenticatorPayload>[]
        }
        upsert: {
          args: Prisma.AuthenticatorUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuthenticatorPayload>
        }
        aggregate: {
          args: Prisma.AuthenticatorAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAuthenticator>
        }
        groupBy: {
          args: Prisma.AuthenticatorGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AuthenticatorGroupByOutputType>[]
        }
        count: {
          args: Prisma.AuthenticatorCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AuthenticatorCountAggregateOutputType> | number
        }
      }
    }
    BugReport: {
      payload: Prisma.$BugReportPayload<ExtArgs>
      fields: Prisma.BugReportFieldRefs
      operations: {
        findUnique: {
          args: Prisma.BugReportFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BugReportPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.BugReportFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BugReportPayload>
        }
        findFirst: {
          args: Prisma.BugReportFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BugReportPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.BugReportFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BugReportPayload>
        }
        findMany: {
          args: Prisma.BugReportFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BugReportPayload>[]
        }
        create: {
          args: Prisma.BugReportCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BugReportPayload>
        }
        createMany: {
          args: Prisma.BugReportCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.BugReportCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BugReportPayload>[]
        }
        delete: {
          args: Prisma.BugReportDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BugReportPayload>
        }
        update: {
          args: Prisma.BugReportUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BugReportPayload>
        }
        deleteMany: {
          args: Prisma.BugReportDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.BugReportUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.BugReportUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BugReportPayload>[]
        }
        upsert: {
          args: Prisma.BugReportUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BugReportPayload>
        }
        aggregate: {
          args: Prisma.BugReportAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateBugReport>
        }
        groupBy: {
          args: Prisma.BugReportGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BugReportGroupByOutputType>[]
        }
        count: {
          args: Prisma.BugReportCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BugReportCountAggregateOutputType> | number
        }
      }
    }
    Comment: {
      payload: Prisma.$CommentPayload<ExtArgs>
      fields: Prisma.CommentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CommentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>
        }
        findFirst: {
          args: Prisma.CommentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>
        }
        findMany: {
          args: Prisma.CommentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>[]
        }
        create: {
          args: Prisma.CommentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>
        }
        createMany: {
          args: Prisma.CommentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>[]
        }
        delete: {
          args: Prisma.CommentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>
        }
        update: {
          args: Prisma.CommentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>
        }
        deleteMany: {
          args: Prisma.CommentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CommentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CommentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>[]
        }
        upsert: {
          args: Prisma.CommentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>
        }
        aggregate: {
          args: Prisma.CommentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateComment>
        }
        groupBy: {
          args: Prisma.CommentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CommentGroupByOutputType>[]
        }
        count: {
          args: Prisma.CommentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CommentCountAggregateOutputType> | number
        }
      }
    }
    Conversation: {
      payload: Prisma.$ConversationPayload<ExtArgs>
      fields: Prisma.ConversationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ConversationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ConversationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload>
        }
        findFirst: {
          args: Prisma.ConversationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ConversationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload>
        }
        findMany: {
          args: Prisma.ConversationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload>[]
        }
        create: {
          args: Prisma.ConversationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload>
        }
        createMany: {
          args: Prisma.ConversationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ConversationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload>[]
        }
        delete: {
          args: Prisma.ConversationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload>
        }
        update: {
          args: Prisma.ConversationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload>
        }
        deleteMany: {
          args: Prisma.ConversationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ConversationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ConversationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload>[]
        }
        upsert: {
          args: Prisma.ConversationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload>
        }
        aggregate: {
          args: Prisma.ConversationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateConversation>
        }
        groupBy: {
          args: Prisma.ConversationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConversationGroupByOutputType>[]
        }
        count: {
          args: Prisma.ConversationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConversationCountAggregateOutputType> | number
        }
      }
    }
    Customer: {
      payload: Prisma.$CustomerPayload<ExtArgs>
      fields: Prisma.CustomerFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CustomerFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>
        }
        findFirst: {
          args: Prisma.CustomerFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>
        }
        findMany: {
          args: Prisma.CustomerFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>[]
        }
        create: {
          args: Prisma.CustomerCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>
        }
        createMany: {
          args: Prisma.CustomerCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>[]
        }
        delete: {
          args: Prisma.CustomerDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>
        }
        update: {
          args: Prisma.CustomerUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>
        }
        deleteMany: {
          args: Prisma.CustomerDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CustomerUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>[]
        }
        upsert: {
          args: Prisma.CustomerUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>
        }
        aggregate: {
          args: Prisma.CustomerAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCustomer>
        }
        groupBy: {
          args: Prisma.CustomerGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CustomerGroupByOutputType>[]
        }
        count: {
          args: Prisma.CustomerCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CustomerCountAggregateOutputType> | number
        }
      }
    }
    CustomerAlert: {
      payload: Prisma.$CustomerAlertPayload<ExtArgs>
      fields: Prisma.CustomerAlertFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CustomerAlertFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerAlertPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CustomerAlertFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerAlertPayload>
        }
        findFirst: {
          args: Prisma.CustomerAlertFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerAlertPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CustomerAlertFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerAlertPayload>
        }
        findMany: {
          args: Prisma.CustomerAlertFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerAlertPayload>[]
        }
        create: {
          args: Prisma.CustomerAlertCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerAlertPayload>
        }
        createMany: {
          args: Prisma.CustomerAlertCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CustomerAlertCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerAlertPayload>[]
        }
        delete: {
          args: Prisma.CustomerAlertDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerAlertPayload>
        }
        update: {
          args: Prisma.CustomerAlertUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerAlertPayload>
        }
        deleteMany: {
          args: Prisma.CustomerAlertDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CustomerAlertUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CustomerAlertUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerAlertPayload>[]
        }
        upsert: {
          args: Prisma.CustomerAlertUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerAlertPayload>
        }
        aggregate: {
          args: Prisma.CustomerAlertAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCustomerAlert>
        }
        groupBy: {
          args: Prisma.CustomerAlertGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CustomerAlertGroupByOutputType>[]
        }
        count: {
          args: Prisma.CustomerAlertCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CustomerAlertCountAggregateOutputType> | number
        }
      }
    }
    DebitCreditNote: {
      payload: Prisma.$DebitCreditNotePayload<ExtArgs>
      fields: Prisma.DebitCreditNoteFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DebitCreditNoteFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DebitCreditNotePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DebitCreditNoteFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DebitCreditNotePayload>
        }
        findFirst: {
          args: Prisma.DebitCreditNoteFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DebitCreditNotePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DebitCreditNoteFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DebitCreditNotePayload>
        }
        findMany: {
          args: Prisma.DebitCreditNoteFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DebitCreditNotePayload>[]
        }
        create: {
          args: Prisma.DebitCreditNoteCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DebitCreditNotePayload>
        }
        createMany: {
          args: Prisma.DebitCreditNoteCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DebitCreditNoteCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DebitCreditNotePayload>[]
        }
        delete: {
          args: Prisma.DebitCreditNoteDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DebitCreditNotePayload>
        }
        update: {
          args: Prisma.DebitCreditNoteUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DebitCreditNotePayload>
        }
        deleteMany: {
          args: Prisma.DebitCreditNoteDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DebitCreditNoteUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DebitCreditNoteUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DebitCreditNotePayload>[]
        }
        upsert: {
          args: Prisma.DebitCreditNoteUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DebitCreditNotePayload>
        }
        aggregate: {
          args: Prisma.DebitCreditNoteAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDebitCreditNote>
        }
        groupBy: {
          args: Prisma.DebitCreditNoteGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DebitCreditNoteGroupByOutputType>[]
        }
        count: {
          args: Prisma.DebitCreditNoteCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DebitCreditNoteCountAggregateOutputType> | number
        }
      }
    }
    FinancialTransaction: {
      payload: Prisma.$FinancialTransactionPayload<ExtArgs>
      fields: Prisma.FinancialTransactionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FinancialTransactionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialTransactionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FinancialTransactionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialTransactionPayload>
        }
        findFirst: {
          args: Prisma.FinancialTransactionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialTransactionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FinancialTransactionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialTransactionPayload>
        }
        findMany: {
          args: Prisma.FinancialTransactionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialTransactionPayload>[]
        }
        create: {
          args: Prisma.FinancialTransactionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialTransactionPayload>
        }
        createMany: {
          args: Prisma.FinancialTransactionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FinancialTransactionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialTransactionPayload>[]
        }
        delete: {
          args: Prisma.FinancialTransactionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialTransactionPayload>
        }
        update: {
          args: Prisma.FinancialTransactionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialTransactionPayload>
        }
        deleteMany: {
          args: Prisma.FinancialTransactionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FinancialTransactionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FinancialTransactionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialTransactionPayload>[]
        }
        upsert: {
          args: Prisma.FinancialTransactionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialTransactionPayload>
        }
        aggregate: {
          args: Prisma.FinancialTransactionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFinancialTransaction>
        }
        groupBy: {
          args: Prisma.FinancialTransactionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FinancialTransactionGroupByOutputType>[]
        }
        count: {
          args: Prisma.FinancialTransactionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FinancialTransactionCountAggregateOutputType> | number
        }
      }
    }
    Goal: {
      payload: Prisma.$GoalPayload<ExtArgs>
      fields: Prisma.GoalFieldRefs
      operations: {
        findUnique: {
          args: Prisma.GoalFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GoalPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.GoalFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GoalPayload>
        }
        findFirst: {
          args: Prisma.GoalFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GoalPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.GoalFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GoalPayload>
        }
        findMany: {
          args: Prisma.GoalFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GoalPayload>[]
        }
        create: {
          args: Prisma.GoalCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GoalPayload>
        }
        createMany: {
          args: Prisma.GoalCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.GoalCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GoalPayload>[]
        }
        delete: {
          args: Prisma.GoalDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GoalPayload>
        }
        update: {
          args: Prisma.GoalUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GoalPayload>
        }
        deleteMany: {
          args: Prisma.GoalDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.GoalUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.GoalUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GoalPayload>[]
        }
        upsert: {
          args: Prisma.GoalUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GoalPayload>
        }
        aggregate: {
          args: Prisma.GoalAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateGoal>
        }
        groupBy: {
          args: Prisma.GoalGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GoalGroupByOutputType>[]
        }
        count: {
          args: Prisma.GoalCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GoalCountAggregateOutputType> | number
        }
      }
    }
    GoalAssignment: {
      payload: Prisma.$GoalAssignmentPayload<ExtArgs>
      fields: Prisma.GoalAssignmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.GoalAssignmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GoalAssignmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.GoalAssignmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GoalAssignmentPayload>
        }
        findFirst: {
          args: Prisma.GoalAssignmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GoalAssignmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.GoalAssignmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GoalAssignmentPayload>
        }
        findMany: {
          args: Prisma.GoalAssignmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GoalAssignmentPayload>[]
        }
        create: {
          args: Prisma.GoalAssignmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GoalAssignmentPayload>
        }
        createMany: {
          args: Prisma.GoalAssignmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.GoalAssignmentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GoalAssignmentPayload>[]
        }
        delete: {
          args: Prisma.GoalAssignmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GoalAssignmentPayload>
        }
        update: {
          args: Prisma.GoalAssignmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GoalAssignmentPayload>
        }
        deleteMany: {
          args: Prisma.GoalAssignmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.GoalAssignmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.GoalAssignmentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GoalAssignmentPayload>[]
        }
        upsert: {
          args: Prisma.GoalAssignmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GoalAssignmentPayload>
        }
        aggregate: {
          args: Prisma.GoalAssignmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateGoalAssignment>
        }
        groupBy: {
          args: Prisma.GoalAssignmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GoalAssignmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.GoalAssignmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GoalAssignmentCountAggregateOutputType> | number
        }
      }
    }
    HrAuditLog: {
      payload: Prisma.$HrAuditLogPayload<ExtArgs>
      fields: Prisma.HrAuditLogFieldRefs
      operations: {
        findUnique: {
          args: Prisma.HrAuditLogFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HrAuditLogPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.HrAuditLogFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HrAuditLogPayload>
        }
        findFirst: {
          args: Prisma.HrAuditLogFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HrAuditLogPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.HrAuditLogFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HrAuditLogPayload>
        }
        findMany: {
          args: Prisma.HrAuditLogFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HrAuditLogPayload>[]
        }
        create: {
          args: Prisma.HrAuditLogCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HrAuditLogPayload>
        }
        createMany: {
          args: Prisma.HrAuditLogCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.HrAuditLogCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HrAuditLogPayload>[]
        }
        delete: {
          args: Prisma.HrAuditLogDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HrAuditLogPayload>
        }
        update: {
          args: Prisma.HrAuditLogUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HrAuditLogPayload>
        }
        deleteMany: {
          args: Prisma.HrAuditLogDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.HrAuditLogUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.HrAuditLogUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HrAuditLogPayload>[]
        }
        upsert: {
          args: Prisma.HrAuditLogUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HrAuditLogPayload>
        }
        aggregate: {
          args: Prisma.HrAuditLogAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateHrAuditLog>
        }
        groupBy: {
          args: Prisma.HrAuditLogGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.HrAuditLogGroupByOutputType>[]
        }
        count: {
          args: Prisma.HrAuditLogCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.HrAuditLogCountAggregateOutputType> | number
        }
      }
    }
    Invoice: {
      payload: Prisma.$InvoicePayload<ExtArgs>
      fields: Prisma.InvoiceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        findFirst: {
          args: Prisma.InvoiceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        findMany: {
          args: Prisma.InvoiceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>[]
        }
        create: {
          args: Prisma.InvoiceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        createMany: {
          args: Prisma.InvoiceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>[]
        }
        delete: {
          args: Prisma.InvoiceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        update: {
          args: Prisma.InvoiceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        deleteMany: {
          args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>[]
        }
        upsert: {
          args: Prisma.InvoiceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        aggregate: {
          args: Prisma.InvoiceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInvoice>
        }
        groupBy: {
          args: Prisma.InvoiceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvoiceGroupByOutputType>[]
        }
        count: {
          args: Prisma.InvoiceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvoiceCountAggregateOutputType> | number
        }
      }
    }
    Message: {
      payload: Prisma.$MessagePayload<ExtArgs>
      fields: Prisma.MessageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MessageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>
        }
        findFirst: {
          args: Prisma.MessageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>
        }
        findMany: {
          args: Prisma.MessageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>[]
        }
        create: {
          args: Prisma.MessageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>
        }
        createMany: {
          args: Prisma.MessageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>[]
        }
        delete: {
          args: Prisma.MessageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>
        }
        update: {
          args: Prisma.MessageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>
        }
        deleteMany: {
          args: Prisma.MessageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MessageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>[]
        }
        upsert: {
          args: Prisma.MessageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>
        }
        aggregate: {
          args: Prisma.MessageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMessage>
        }
        groupBy: {
          args: Prisma.MessageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MessageGroupByOutputType>[]
        }
        count: {
          args: Prisma.MessageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MessageCountAggregateOutputType> | number
        }
      }
    }
    Metric: {
      payload: Prisma.$MetricPayload<ExtArgs>
      fields: Prisma.MetricFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MetricFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MetricPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MetricFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MetricPayload>
        }
        findFirst: {
          args: Prisma.MetricFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MetricPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MetricFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MetricPayload>
        }
        findMany: {
          args: Prisma.MetricFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MetricPayload>[]
        }
        create: {
          args: Prisma.MetricCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MetricPayload>
        }
        createMany: {
          args: Prisma.MetricCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MetricCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MetricPayload>[]
        }
        delete: {
          args: Prisma.MetricDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MetricPayload>
        }
        update: {
          args: Prisma.MetricUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MetricPayload>
        }
        deleteMany: {
          args: Prisma.MetricDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MetricUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MetricUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MetricPayload>[]
        }
        upsert: {
          args: Prisma.MetricUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MetricPayload>
        }
        aggregate: {
          args: Prisma.MetricAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMetric>
        }
        groupBy: {
          args: Prisma.MetricGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MetricGroupByOutputType>[]
        }
        count: {
          args: Prisma.MetricCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MetricCountAggregateOutputType> | number
        }
      }
    }
    Notification: {
      payload: Prisma.$NotificationPayload<ExtArgs>
      fields: Prisma.NotificationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NotificationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        findFirst: {
          args: Prisma.NotificationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        findMany: {
          args: Prisma.NotificationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>[]
        }
        create: {
          args: Prisma.NotificationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        createMany: {
          args: Prisma.NotificationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>[]
        }
        delete: {
          args: Prisma.NotificationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        update: {
          args: Prisma.NotificationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        deleteMany: {
          args: Prisma.NotificationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NotificationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>[]
        }
        upsert: {
          args: Prisma.NotificationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        aggregate: {
          args: Prisma.NotificationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNotification>
        }
        groupBy: {
          args: Prisma.NotificationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotificationGroupByOutputType>[]
        }
        count: {
          args: Prisma.NotificationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotificationCountAggregateOutputType> | number
        }
      }
    }
    NotificationExecution: {
      payload: Prisma.$NotificationExecutionPayload<ExtArgs>
      fields: Prisma.NotificationExecutionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NotificationExecutionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationExecutionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NotificationExecutionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationExecutionPayload>
        }
        findFirst: {
          args: Prisma.NotificationExecutionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationExecutionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NotificationExecutionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationExecutionPayload>
        }
        findMany: {
          args: Prisma.NotificationExecutionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationExecutionPayload>[]
        }
        create: {
          args: Prisma.NotificationExecutionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationExecutionPayload>
        }
        createMany: {
          args: Prisma.NotificationExecutionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NotificationExecutionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationExecutionPayload>[]
        }
        delete: {
          args: Prisma.NotificationExecutionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationExecutionPayload>
        }
        update: {
          args: Prisma.NotificationExecutionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationExecutionPayload>
        }
        deleteMany: {
          args: Prisma.NotificationExecutionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NotificationExecutionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NotificationExecutionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationExecutionPayload>[]
        }
        upsert: {
          args: Prisma.NotificationExecutionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationExecutionPayload>
        }
        aggregate: {
          args: Prisma.NotificationExecutionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNotificationExecution>
        }
        groupBy: {
          args: Prisma.NotificationExecutionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotificationExecutionGroupByOutputType>[]
        }
        count: {
          args: Prisma.NotificationExecutionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotificationExecutionCountAggregateOutputType> | number
        }
      }
    }
    NotificationSettings: {
      payload: Prisma.$NotificationSettingsPayload<ExtArgs>
      fields: Prisma.NotificationSettingsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NotificationSettingsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationSettingsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NotificationSettingsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
        }
        findFirst: {
          args: Prisma.NotificationSettingsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationSettingsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NotificationSettingsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
        }
        findMany: {
          args: Prisma.NotificationSettingsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>[]
        }
        create: {
          args: Prisma.NotificationSettingsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
        }
        createMany: {
          args: Prisma.NotificationSettingsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NotificationSettingsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>[]
        }
        delete: {
          args: Prisma.NotificationSettingsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
        }
        update: {
          args: Prisma.NotificationSettingsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
        }
        deleteMany: {
          args: Prisma.NotificationSettingsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NotificationSettingsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NotificationSettingsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>[]
        }
        upsert: {
          args: Prisma.NotificationSettingsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
        }
        aggregate: {
          args: Prisma.NotificationSettingsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNotificationSettings>
        }
        groupBy: {
          args: Prisma.NotificationSettingsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotificationSettingsGroupByOutputType>[]
        }
        count: {
          args: Prisma.NotificationSettingsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotificationSettingsCountAggregateOutputType> | number
        }
      }
    }
    PackageItem: {
      payload: Prisma.$PackageItemPayload<ExtArgs>
      fields: Prisma.PackageItemFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PackageItemFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PackageItemPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PackageItemFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PackageItemPayload>
        }
        findFirst: {
          args: Prisma.PackageItemFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PackageItemPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PackageItemFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PackageItemPayload>
        }
        findMany: {
          args: Prisma.PackageItemFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PackageItemPayload>[]
        }
        create: {
          args: Prisma.PackageItemCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PackageItemPayload>
        }
        createMany: {
          args: Prisma.PackageItemCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PackageItemCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PackageItemPayload>[]
        }
        delete: {
          args: Prisma.PackageItemDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PackageItemPayload>
        }
        update: {
          args: Prisma.PackageItemUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PackageItemPayload>
        }
        deleteMany: {
          args: Prisma.PackageItemDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PackageItemUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PackageItemUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PackageItemPayload>[]
        }
        upsert: {
          args: Prisma.PackageItemUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PackageItemPayload>
        }
        aggregate: {
          args: Prisma.PackageItemAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePackageItem>
        }
        groupBy: {
          args: Prisma.PackageItemGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PackageItemGroupByOutputType>[]
        }
        count: {
          args: Prisma.PackageItemCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PackageItemCountAggregateOutputType> | number
        }
      }
    }
    Participant: {
      payload: Prisma.$ParticipantPayload<ExtArgs>
      fields: Prisma.ParticipantFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ParticipantFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ParticipantPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ParticipantFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ParticipantPayload>
        }
        findFirst: {
          args: Prisma.ParticipantFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ParticipantPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ParticipantFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ParticipantPayload>
        }
        findMany: {
          args: Prisma.ParticipantFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ParticipantPayload>[]
        }
        create: {
          args: Prisma.ParticipantCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ParticipantPayload>
        }
        createMany: {
          args: Prisma.ParticipantCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ParticipantCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ParticipantPayload>[]
        }
        delete: {
          args: Prisma.ParticipantDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ParticipantPayload>
        }
        update: {
          args: Prisma.ParticipantUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ParticipantPayload>
        }
        deleteMany: {
          args: Prisma.ParticipantDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ParticipantUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ParticipantUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ParticipantPayload>[]
        }
        upsert: {
          args: Prisma.ParticipantUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ParticipantPayload>
        }
        aggregate: {
          args: Prisma.ParticipantAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateParticipant>
        }
        groupBy: {
          args: Prisma.ParticipantGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ParticipantGroupByOutputType>[]
        }
        count: {
          args: Prisma.ParticipantCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ParticipantCountAggregateOutputType> | number
        }
      }
    }
    PayAdjustment: {
      payload: Prisma.$PayAdjustmentPayload<ExtArgs>
      fields: Prisma.PayAdjustmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PayAdjustmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayAdjustmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PayAdjustmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayAdjustmentPayload>
        }
        findFirst: {
          args: Prisma.PayAdjustmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayAdjustmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PayAdjustmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayAdjustmentPayload>
        }
        findMany: {
          args: Prisma.PayAdjustmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayAdjustmentPayload>[]
        }
        create: {
          args: Prisma.PayAdjustmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayAdjustmentPayload>
        }
        createMany: {
          args: Prisma.PayAdjustmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PayAdjustmentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayAdjustmentPayload>[]
        }
        delete: {
          args: Prisma.PayAdjustmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayAdjustmentPayload>
        }
        update: {
          args: Prisma.PayAdjustmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayAdjustmentPayload>
        }
        deleteMany: {
          args: Prisma.PayAdjustmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PayAdjustmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PayAdjustmentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayAdjustmentPayload>[]
        }
        upsert: {
          args: Prisma.PayAdjustmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayAdjustmentPayload>
        }
        aggregate: {
          args: Prisma.PayAdjustmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePayAdjustment>
        }
        groupBy: {
          args: Prisma.PayAdjustmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PayAdjustmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.PayAdjustmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PayAdjustmentCountAggregateOutputType> | number
        }
      }
    }
    PayPeriod: {
      payload: Prisma.$PayPeriodPayload<ExtArgs>
      fields: Prisma.PayPeriodFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PayPeriodFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayPeriodPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PayPeriodFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayPeriodPayload>
        }
        findFirst: {
          args: Prisma.PayPeriodFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayPeriodPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PayPeriodFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayPeriodPayload>
        }
        findMany: {
          args: Prisma.PayPeriodFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayPeriodPayload>[]
        }
        create: {
          args: Prisma.PayPeriodCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayPeriodPayload>
        }
        createMany: {
          args: Prisma.PayPeriodCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PayPeriodCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayPeriodPayload>[]
        }
        delete: {
          args: Prisma.PayPeriodDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayPeriodPayload>
        }
        update: {
          args: Prisma.PayPeriodUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayPeriodPayload>
        }
        deleteMany: {
          args: Prisma.PayPeriodDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PayPeriodUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PayPeriodUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayPeriodPayload>[]
        }
        upsert: {
          args: Prisma.PayPeriodUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayPeriodPayload>
        }
        aggregate: {
          args: Prisma.PayPeriodAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePayPeriod>
        }
        groupBy: {
          args: Prisma.PayPeriodGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PayPeriodGroupByOutputType>[]
        }
        count: {
          args: Prisma.PayPeriodCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PayPeriodCountAggregateOutputType> | number
        }
      }
    }
    PayStatement: {
      payload: Prisma.$PayStatementPayload<ExtArgs>
      fields: Prisma.PayStatementFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PayStatementFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayStatementPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PayStatementFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayStatementPayload>
        }
        findFirst: {
          args: Prisma.PayStatementFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayStatementPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PayStatementFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayStatementPayload>
        }
        findMany: {
          args: Prisma.PayStatementFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayStatementPayload>[]
        }
        create: {
          args: Prisma.PayStatementCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayStatementPayload>
        }
        createMany: {
          args: Prisma.PayStatementCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PayStatementCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayStatementPayload>[]
        }
        delete: {
          args: Prisma.PayStatementDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayStatementPayload>
        }
        update: {
          args: Prisma.PayStatementUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayStatementPayload>
        }
        deleteMany: {
          args: Prisma.PayStatementDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PayStatementUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PayStatementUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayStatementPayload>[]
        }
        upsert: {
          args: Prisma.PayStatementUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayStatementPayload>
        }
        aggregate: {
          args: Prisma.PayStatementAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePayStatement>
        }
        groupBy: {
          args: Prisma.PayStatementGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PayStatementGroupByOutputType>[]
        }
        count: {
          args: Prisma.PayStatementCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PayStatementCountAggregateOutputType> | number
        }
      }
    }
    PaymentRecord: {
      payload: Prisma.$PaymentRecordPayload<ExtArgs>
      fields: Prisma.PaymentRecordFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PaymentRecordFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentRecordPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PaymentRecordFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentRecordPayload>
        }
        findFirst: {
          args: Prisma.PaymentRecordFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentRecordPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PaymentRecordFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentRecordPayload>
        }
        findMany: {
          args: Prisma.PaymentRecordFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentRecordPayload>[]
        }
        create: {
          args: Prisma.PaymentRecordCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentRecordPayload>
        }
        createMany: {
          args: Prisma.PaymentRecordCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PaymentRecordCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentRecordPayload>[]
        }
        delete: {
          args: Prisma.PaymentRecordDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentRecordPayload>
        }
        update: {
          args: Prisma.PaymentRecordUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentRecordPayload>
        }
        deleteMany: {
          args: Prisma.PaymentRecordDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PaymentRecordUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PaymentRecordUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentRecordPayload>[]
        }
        upsert: {
          args: Prisma.PaymentRecordUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentRecordPayload>
        }
        aggregate: {
          args: Prisma.PaymentRecordAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePaymentRecord>
        }
        groupBy: {
          args: Prisma.PaymentRecordGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentRecordGroupByOutputType>[]
        }
        count: {
          args: Prisma.PaymentRecordCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentRecordCountAggregateOutputType> | number
        }
      }
    }
    Pet: {
      payload: Prisma.$PetPayload<ExtArgs>
      fields: Prisma.PetFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PetFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PetPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PetFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PetPayload>
        }
        findFirst: {
          args: Prisma.PetFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PetPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PetFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PetPayload>
        }
        findMany: {
          args: Prisma.PetFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PetPayload>[]
        }
        create: {
          args: Prisma.PetCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PetPayload>
        }
        createMany: {
          args: Prisma.PetCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PetCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PetPayload>[]
        }
        delete: {
          args: Prisma.PetDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PetPayload>
        }
        update: {
          args: Prisma.PetUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PetPayload>
        }
        deleteMany: {
          args: Prisma.PetDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PetUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PetUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PetPayload>[]
        }
        upsert: {
          args: Prisma.PetUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PetPayload>
        }
        aggregate: {
          args: Prisma.PetAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePet>
        }
        groupBy: {
          args: Prisma.PetGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PetGroupByOutputType>[]
        }
        count: {
          args: Prisma.PetCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PetCountAggregateOutputType> | number
        }
      }
    }
    Post: {
      payload: Prisma.$PostPayload<ExtArgs>
      fields: Prisma.PostFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PostFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PostFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostPayload>
        }
        findFirst: {
          args: Prisma.PostFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PostFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostPayload>
        }
        findMany: {
          args: Prisma.PostFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostPayload>[]
        }
        create: {
          args: Prisma.PostCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostPayload>
        }
        createMany: {
          args: Prisma.PostCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PostCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostPayload>[]
        }
        delete: {
          args: Prisma.PostDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostPayload>
        }
        update: {
          args: Prisma.PostUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostPayload>
        }
        deleteMany: {
          args: Prisma.PostDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PostUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PostUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostPayload>[]
        }
        upsert: {
          args: Prisma.PostUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostPayload>
        }
        aggregate: {
          args: Prisma.PostAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePost>
        }
        groupBy: {
          args: Prisma.PostGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PostGroupByOutputType>[]
        }
        count: {
          args: Prisma.PostCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PostCountAggregateOutputType> | number
        }
      }
    }
    Product: {
      payload: Prisma.$ProductPayload<ExtArgs>
      fields: Prisma.ProductFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProductFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>
        }
        findFirst: {
          args: Prisma.ProductFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>
        }
        findMany: {
          args: Prisma.ProductFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>[]
        }
        create: {
          args: Prisma.ProductCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>
        }
        createMany: {
          args: Prisma.ProductCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>[]
        }
        delete: {
          args: Prisma.ProductDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>
        }
        update: {
          args: Prisma.ProductUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>
        }
        deleteMany: {
          args: Prisma.ProductDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProductUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>[]
        }
        upsert: {
          args: Prisma.ProductUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>
        }
        aggregate: {
          args: Prisma.ProductAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProduct>
        }
        groupBy: {
          args: Prisma.ProductGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProductGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProductCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProductCountAggregateOutputType> | number
        }
      }
    }
    PushSubscription: {
      payload: Prisma.$PushSubscriptionPayload<ExtArgs>
      fields: Prisma.PushSubscriptionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PushSubscriptionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PushSubscriptionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PushSubscriptionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
        }
        findFirst: {
          args: Prisma.PushSubscriptionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PushSubscriptionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PushSubscriptionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
        }
        findMany: {
          args: Prisma.PushSubscriptionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>[]
        }
        create: {
          args: Prisma.PushSubscriptionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
        }
        createMany: {
          args: Prisma.PushSubscriptionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PushSubscriptionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>[]
        }
        delete: {
          args: Prisma.PushSubscriptionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
        }
        update: {
          args: Prisma.PushSubscriptionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
        }
        deleteMany: {
          args: Prisma.PushSubscriptionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PushSubscriptionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PushSubscriptionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>[]
        }
        upsert: {
          args: Prisma.PushSubscriptionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
        }
        aggregate: {
          args: Prisma.PushSubscriptionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePushSubscription>
        }
        groupBy: {
          args: Prisma.PushSubscriptionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PushSubscriptionGroupByOutputType>[]
        }
        count: {
          args: Prisma.PushSubscriptionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PushSubscriptionCountAggregateOutputType> | number
        }
      }
    }
    Quote: {
      payload: Prisma.$QuotePayload<ExtArgs>
      fields: Prisma.QuoteFieldRefs
      operations: {
        findUnique: {
          args: Prisma.QuoteFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuotePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.QuoteFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuotePayload>
        }
        findFirst: {
          args: Prisma.QuoteFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuotePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.QuoteFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuotePayload>
        }
        findMany: {
          args: Prisma.QuoteFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuotePayload>[]
        }
        create: {
          args: Prisma.QuoteCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuotePayload>
        }
        createMany: {
          args: Prisma.QuoteCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.QuoteCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuotePayload>[]
        }
        delete: {
          args: Prisma.QuoteDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuotePayload>
        }
        update: {
          args: Prisma.QuoteUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuotePayload>
        }
        deleteMany: {
          args: Prisma.QuoteDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.QuoteUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.QuoteUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuotePayload>[]
        }
        upsert: {
          args: Prisma.QuoteUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuotePayload>
        }
        aggregate: {
          args: Prisma.QuoteAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateQuote>
        }
        groupBy: {
          args: Prisma.QuoteGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.QuoteGroupByOutputType>[]
        }
        count: {
          args: Prisma.QuoteCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.QuoteCountAggregateOutputType> | number
        }
      }
    }
    QuoteItem: {
      payload: Prisma.$QuoteItemPayload<ExtArgs>
      fields: Prisma.QuoteItemFieldRefs
      operations: {
        findUnique: {
          args: Prisma.QuoteItemFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuoteItemPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.QuoteItemFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuoteItemPayload>
        }
        findFirst: {
          args: Prisma.QuoteItemFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuoteItemPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.QuoteItemFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuoteItemPayload>
        }
        findMany: {
          args: Prisma.QuoteItemFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuoteItemPayload>[]
        }
        create: {
          args: Prisma.QuoteItemCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuoteItemPayload>
        }
        createMany: {
          args: Prisma.QuoteItemCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.QuoteItemCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuoteItemPayload>[]
        }
        delete: {
          args: Prisma.QuoteItemDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuoteItemPayload>
        }
        update: {
          args: Prisma.QuoteItemUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuoteItemPayload>
        }
        deleteMany: {
          args: Prisma.QuoteItemDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.QuoteItemUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.QuoteItemUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuoteItemPayload>[]
        }
        upsert: {
          args: Prisma.QuoteItemUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuoteItemPayload>
        }
        aggregate: {
          args: Prisma.QuoteItemAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateQuoteItem>
        }
        groupBy: {
          args: Prisma.QuoteItemGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.QuoteItemGroupByOutputType>[]
        }
        count: {
          args: Prisma.QuoteItemCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.QuoteItemCountAggregateOutputType> | number
        }
      }
    }
    Reaction: {
      payload: Prisma.$ReactionPayload<ExtArgs>
      fields: Prisma.ReactionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ReactionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReactionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ReactionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReactionPayload>
        }
        findFirst: {
          args: Prisma.ReactionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReactionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ReactionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReactionPayload>
        }
        findMany: {
          args: Prisma.ReactionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReactionPayload>[]
        }
        create: {
          args: Prisma.ReactionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReactionPayload>
        }
        createMany: {
          args: Prisma.ReactionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ReactionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReactionPayload>[]
        }
        delete: {
          args: Prisma.ReactionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReactionPayload>
        }
        update: {
          args: Prisma.ReactionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReactionPayload>
        }
        deleteMany: {
          args: Prisma.ReactionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ReactionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ReactionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReactionPayload>[]
        }
        upsert: {
          args: Prisma.ReactionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReactionPayload>
        }
        aggregate: {
          args: Prisma.ReactionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateReaction>
        }
        groupBy: {
          args: Prisma.ReactionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReactionGroupByOutputType>[]
        }
        count: {
          args: Prisma.ReactionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReactionCountAggregateOutputType> | number
        }
      }
    }
    RecurringPackage: {
      payload: Prisma.$RecurringPackagePayload<ExtArgs>
      fields: Prisma.RecurringPackageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RecurringPackageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecurringPackagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RecurringPackageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecurringPackagePayload>
        }
        findFirst: {
          args: Prisma.RecurringPackageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecurringPackagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RecurringPackageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecurringPackagePayload>
        }
        findMany: {
          args: Prisma.RecurringPackageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecurringPackagePayload>[]
        }
        create: {
          args: Prisma.RecurringPackageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecurringPackagePayload>
        }
        createMany: {
          args: Prisma.RecurringPackageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RecurringPackageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecurringPackagePayload>[]
        }
        delete: {
          args: Prisma.RecurringPackageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecurringPackagePayload>
        }
        update: {
          args: Prisma.RecurringPackageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecurringPackagePayload>
        }
        deleteMany: {
          args: Prisma.RecurringPackageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RecurringPackageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RecurringPackageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecurringPackagePayload>[]
        }
        upsert: {
          args: Prisma.RecurringPackageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecurringPackagePayload>
        }
        aggregate: {
          args: Prisma.RecurringPackageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRecurringPackage>
        }
        groupBy: {
          args: Prisma.RecurringPackageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RecurringPackageGroupByOutputType>[]
        }
        count: {
          args: Prisma.RecurringPackageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RecurringPackageCountAggregateOutputType> | number
        }
      }
    }
    RolePermission: {
      payload: Prisma.$RolePermissionPayload<ExtArgs>
      fields: Prisma.RolePermissionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RolePermissionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RolePermissionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>
        }
        findFirst: {
          args: Prisma.RolePermissionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RolePermissionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>
        }
        findMany: {
          args: Prisma.RolePermissionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
        }
        create: {
          args: Prisma.RolePermissionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>
        }
        createMany: {
          args: Prisma.RolePermissionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RolePermissionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
        }
        delete: {
          args: Prisma.RolePermissionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>
        }
        update: {
          args: Prisma.RolePermissionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>
        }
        deleteMany: {
          args: Prisma.RolePermissionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RolePermissionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RolePermissionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
        }
        upsert: {
          args: Prisma.RolePermissionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>
        }
        aggregate: {
          args: Prisma.RolePermissionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRolePermission>
        }
        groupBy: {
          args: Prisma.RolePermissionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RolePermissionGroupByOutputType>[]
        }
        count: {
          args: Prisma.RolePermissionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RolePermissionCountAggregateOutputType> | number
        }
      }
    }
    ScheduledNotification: {
      payload: Prisma.$ScheduledNotificationPayload<ExtArgs>
      fields: Prisma.ScheduledNotificationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ScheduledNotificationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduledNotificationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ScheduledNotificationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduledNotificationPayload>
        }
        findFirst: {
          args: Prisma.ScheduledNotificationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduledNotificationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ScheduledNotificationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduledNotificationPayload>
        }
        findMany: {
          args: Prisma.ScheduledNotificationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduledNotificationPayload>[]
        }
        create: {
          args: Prisma.ScheduledNotificationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduledNotificationPayload>
        }
        createMany: {
          args: Prisma.ScheduledNotificationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ScheduledNotificationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduledNotificationPayload>[]
        }
        delete: {
          args: Prisma.ScheduledNotificationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduledNotificationPayload>
        }
        update: {
          args: Prisma.ScheduledNotificationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduledNotificationPayload>
        }
        deleteMany: {
          args: Prisma.ScheduledNotificationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ScheduledNotificationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ScheduledNotificationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduledNotificationPayload>[]
        }
        upsert: {
          args: Prisma.ScheduledNotificationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduledNotificationPayload>
        }
        aggregate: {
          args: Prisma.ScheduledNotificationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateScheduledNotification>
        }
        groupBy: {
          args: Prisma.ScheduledNotificationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ScheduledNotificationGroupByOutputType>[]
        }
        count: {
          args: Prisma.ScheduledNotificationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ScheduledNotificationCountAggregateOutputType> | number
        }
      }
    }
    Service: {
      payload: Prisma.$ServicePayload<ExtArgs>
      fields: Prisma.ServiceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ServiceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>
        }
        findFirst: {
          args: Prisma.ServiceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>
        }
        findMany: {
          args: Prisma.ServiceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>[]
        }
        create: {
          args: Prisma.ServiceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>
        }
        createMany: {
          args: Prisma.ServiceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>[]
        }
        delete: {
          args: Prisma.ServiceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>
        }
        update: {
          args: Prisma.ServiceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>
        }
        deleteMany: {
          args: Prisma.ServiceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ServiceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ServiceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>[]
        }
        upsert: {
          args: Prisma.ServiceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>
        }
        aggregate: {
          args: Prisma.ServiceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateService>
        }
        groupBy: {
          args: Prisma.ServiceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ServiceGroupByOutputType>[]
        }
        count: {
          args: Prisma.ServiceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ServiceCountAggregateOutputType> | number
        }
      }
    }
    ServiceExecution: {
      payload: Prisma.$ServiceExecutionPayload<ExtArgs>
      fields: Prisma.ServiceExecutionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ServiceExecutionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceExecutionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ServiceExecutionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceExecutionPayload>
        }
        findFirst: {
          args: Prisma.ServiceExecutionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceExecutionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ServiceExecutionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceExecutionPayload>
        }
        findMany: {
          args: Prisma.ServiceExecutionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceExecutionPayload>[]
        }
        create: {
          args: Prisma.ServiceExecutionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceExecutionPayload>
        }
        createMany: {
          args: Prisma.ServiceExecutionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ServiceExecutionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceExecutionPayload>[]
        }
        delete: {
          args: Prisma.ServiceExecutionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceExecutionPayload>
        }
        update: {
          args: Prisma.ServiceExecutionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceExecutionPayload>
        }
        deleteMany: {
          args: Prisma.ServiceExecutionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ServiceExecutionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ServiceExecutionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceExecutionPayload>[]
        }
        upsert: {
          args: Prisma.ServiceExecutionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceExecutionPayload>
        }
        aggregate: {
          args: Prisma.ServiceExecutionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateServiceExecution>
        }
        groupBy: {
          args: Prisma.ServiceExecutionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ServiceExecutionGroupByOutputType>[]
        }
        count: {
          args: Prisma.ServiceExecutionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ServiceExecutionCountAggregateOutputType> | number
        }
      }
    }
    StaffProfile: {
      payload: Prisma.$StaffProfilePayload<ExtArgs>
      fields: Prisma.StaffProfileFieldRefs
      operations: {
        findUnique: {
          args: Prisma.StaffProfileFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffProfilePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.StaffProfileFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffProfilePayload>
        }
        findFirst: {
          args: Prisma.StaffProfileFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffProfilePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.StaffProfileFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffProfilePayload>
        }
        findMany: {
          args: Prisma.StaffProfileFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffProfilePayload>[]
        }
        create: {
          args: Prisma.StaffProfileCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffProfilePayload>
        }
        createMany: {
          args: Prisma.StaffProfileCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.StaffProfileCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffProfilePayload>[]
        }
        delete: {
          args: Prisma.StaffProfileDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffProfilePayload>
        }
        update: {
          args: Prisma.StaffProfileUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffProfilePayload>
        }
        deleteMany: {
          args: Prisma.StaffProfileDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.StaffProfileUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.StaffProfileUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffProfilePayload>[]
        }
        upsert: {
          args: Prisma.StaffProfileUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffProfilePayload>
        }
        aggregate: {
          args: Prisma.StaffProfileAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateStaffProfile>
        }
        groupBy: {
          args: Prisma.StaffProfileGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StaffProfileGroupByOutputType>[]
        }
        count: {
          args: Prisma.StaffProfileCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StaffProfileCountAggregateOutputType> | number
        }
      }
    }
    StatusHistory: {
      payload: Prisma.$StatusHistoryPayload<ExtArgs>
      fields: Prisma.StatusHistoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.StatusHistoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StatusHistoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.StatusHistoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StatusHistoryPayload>
        }
        findFirst: {
          args: Prisma.StatusHistoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StatusHistoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.StatusHistoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StatusHistoryPayload>
        }
        findMany: {
          args: Prisma.StatusHistoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StatusHistoryPayload>[]
        }
        create: {
          args: Prisma.StatusHistoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StatusHistoryPayload>
        }
        createMany: {
          args: Prisma.StatusHistoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.StatusHistoryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StatusHistoryPayload>[]
        }
        delete: {
          args: Prisma.StatusHistoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StatusHistoryPayload>
        }
        update: {
          args: Prisma.StatusHistoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StatusHistoryPayload>
        }
        deleteMany: {
          args: Prisma.StatusHistoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.StatusHistoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.StatusHistoryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StatusHistoryPayload>[]
        }
        upsert: {
          args: Prisma.StatusHistoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StatusHistoryPayload>
        }
        aggregate: {
          args: Prisma.StatusHistoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateStatusHistory>
        }
        groupBy: {
          args: Prisma.StatusHistoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StatusHistoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.StatusHistoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StatusHistoryCountAggregateOutputType> | number
        }
      }
    }
    TransportDetails: {
      payload: Prisma.$TransportDetailsPayload<ExtArgs>
      fields: Prisma.TransportDetailsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TransportDetailsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransportDetailsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TransportDetailsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransportDetailsPayload>
        }
        findFirst: {
          args: Prisma.TransportDetailsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransportDetailsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TransportDetailsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransportDetailsPayload>
        }
        findMany: {
          args: Prisma.TransportDetailsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransportDetailsPayload>[]
        }
        create: {
          args: Prisma.TransportDetailsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransportDetailsPayload>
        }
        createMany: {
          args: Prisma.TransportDetailsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TransportDetailsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransportDetailsPayload>[]
        }
        delete: {
          args: Prisma.TransportDetailsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransportDetailsPayload>
        }
        update: {
          args: Prisma.TransportDetailsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransportDetailsPayload>
        }
        deleteMany: {
          args: Prisma.TransportDetailsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TransportDetailsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TransportDetailsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransportDetailsPayload>[]
        }
        upsert: {
          args: Prisma.TransportDetailsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransportDetailsPayload>
        }
        aggregate: {
          args: Prisma.TransportDetailsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTransportDetails>
        }
        groupBy: {
          args: Prisma.TransportDetailsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TransportDetailsGroupByOutputType>[]
        }
        count: {
          args: Prisma.TransportDetailsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TransportDetailsCountAggregateOutputType> | number
        }
      }
    }
    TransportLegExecution: {
      payload: Prisma.$TransportLegExecutionPayload<ExtArgs>
      fields: Prisma.TransportLegExecutionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TransportLegExecutionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransportLegExecutionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TransportLegExecutionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransportLegExecutionPayload>
        }
        findFirst: {
          args: Prisma.TransportLegExecutionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransportLegExecutionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TransportLegExecutionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransportLegExecutionPayload>
        }
        findMany: {
          args: Prisma.TransportLegExecutionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransportLegExecutionPayload>[]
        }
        create: {
          args: Prisma.TransportLegExecutionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransportLegExecutionPayload>
        }
        createMany: {
          args: Prisma.TransportLegExecutionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TransportLegExecutionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransportLegExecutionPayload>[]
        }
        delete: {
          args: Prisma.TransportLegExecutionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransportLegExecutionPayload>
        }
        update: {
          args: Prisma.TransportLegExecutionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransportLegExecutionPayload>
        }
        deleteMany: {
          args: Prisma.TransportLegExecutionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TransportLegExecutionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TransportLegExecutionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransportLegExecutionPayload>[]
        }
        upsert: {
          args: Prisma.TransportLegExecutionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransportLegExecutionPayload>
        }
        aggregate: {
          args: Prisma.TransportLegExecutionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTransportLegExecution>
        }
        groupBy: {
          args: Prisma.TransportLegExecutionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TransportLegExecutionGroupByOutputType>[]
        }
        count: {
          args: Prisma.TransportLegExecutionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TransportLegExecutionCountAggregateOutputType> | number
        }
      }
    }
    TransportLeg: {
      payload: Prisma.$TransportLegPayload<ExtArgs>
      fields: Prisma.TransportLegFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TransportLegFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransportLegPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TransportLegFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransportLegPayload>
        }
        findFirst: {
          args: Prisma.TransportLegFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransportLegPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TransportLegFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransportLegPayload>
        }
        findMany: {
          args: Prisma.TransportLegFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransportLegPayload>[]
        }
        create: {
          args: Prisma.TransportLegCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransportLegPayload>
        }
        createMany: {
          args: Prisma.TransportLegCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TransportLegCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransportLegPayload>[]
        }
        delete: {
          args: Prisma.TransportLegDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransportLegPayload>
        }
        update: {
          args: Prisma.TransportLegUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransportLegPayload>
        }
        deleteMany: {
          args: Prisma.TransportLegDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TransportLegUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TransportLegUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransportLegPayload>[]
        }
        upsert: {
          args: Prisma.TransportLegUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransportLegPayload>
        }
        aggregate: {
          args: Prisma.TransportLegAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTransportLeg>
        }
        groupBy: {
          args: Prisma.TransportLegGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TransportLegGroupByOutputType>[]
        }
        count: {
          args: Prisma.TransportLegCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TransportLegCountAggregateOutputType> | number
        }
      }
    }
    RouteCache: {
      payload: Prisma.$RouteCachePayload<ExtArgs>
      fields: Prisma.RouteCacheFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RouteCacheFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteCachePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RouteCacheFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteCachePayload>
        }
        findFirst: {
          args: Prisma.RouteCacheFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteCachePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RouteCacheFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteCachePayload>
        }
        findMany: {
          args: Prisma.RouteCacheFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteCachePayload>[]
        }
        create: {
          args: Prisma.RouteCacheCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteCachePayload>
        }
        createMany: {
          args: Prisma.RouteCacheCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RouteCacheCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteCachePayload>[]
        }
        delete: {
          args: Prisma.RouteCacheDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteCachePayload>
        }
        update: {
          args: Prisma.RouteCacheUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteCachePayload>
        }
        deleteMany: {
          args: Prisma.RouteCacheDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RouteCacheUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RouteCacheUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteCachePayload>[]
        }
        upsert: {
          args: Prisma.RouteCacheUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteCachePayload>
        }
        aggregate: {
          args: Prisma.RouteCacheAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRouteCache>
        }
        groupBy: {
          args: Prisma.RouteCacheGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RouteCacheGroupByOutputType>[]
        }
        count: {
          args: Prisma.RouteCacheCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RouteCacheCountAggregateOutputType> | number
        }
      }
    }
    TransportSettings: {
      payload: Prisma.$TransportSettingsPayload<ExtArgs>
      fields: Prisma.TransportSettingsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TransportSettingsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransportSettingsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TransportSettingsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransportSettingsPayload>
        }
        findFirst: {
          args: Prisma.TransportSettingsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransportSettingsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TransportSettingsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransportSettingsPayload>
        }
        findMany: {
          args: Prisma.TransportSettingsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransportSettingsPayload>[]
        }
        create: {
          args: Prisma.TransportSettingsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransportSettingsPayload>
        }
        createMany: {
          args: Prisma.TransportSettingsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TransportSettingsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransportSettingsPayload>[]
        }
        delete: {
          args: Prisma.TransportSettingsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransportSettingsPayload>
        }
        update: {
          args: Prisma.TransportSettingsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransportSettingsPayload>
        }
        deleteMany: {
          args: Prisma.TransportSettingsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TransportSettingsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TransportSettingsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransportSettingsPayload>[]
        }
        upsert: {
          args: Prisma.TransportSettingsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransportSettingsPayload>
        }
        aggregate: {
          args: Prisma.TransportSettingsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTransportSettings>
        }
        groupBy: {
          args: Prisma.TransportSettingsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TransportSettingsGroupByOutputType>[]
        }
        count: {
          args: Prisma.TransportSettingsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TransportSettingsCountAggregateOutputType> | number
        }
      }
    }
    User: {
      payload: Prisma.$UserPayload<ExtArgs>
      fields: Prisma.UserFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        findFirst: {
          args: Prisma.UserFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        findMany: {
          args: Prisma.UserFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        create: {
          args: Prisma.UserCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        createMany: {
          args: Prisma.UserCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        delete: {
          args: Prisma.UserDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        update: {
          args: Prisma.UserUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        deleteMany: {
          args: Prisma.UserDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        upsert: {
          args: Prisma.UserUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        aggregate: {
          args: Prisma.UserAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUser>
        }
        groupBy: {
          args: Prisma.UserGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserCountAggregateOutputType> | number
        }
      }
    }
    UserNotificationPreference: {
      payload: Prisma.$UserNotificationPreferencePayload<ExtArgs>
      fields: Prisma.UserNotificationPreferenceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserNotificationPreferenceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserNotificationPreferencePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserNotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserNotificationPreferencePayload>
        }
        findFirst: {
          args: Prisma.UserNotificationPreferenceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserNotificationPreferencePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserNotificationPreferenceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserNotificationPreferencePayload>
        }
        findMany: {
          args: Prisma.UserNotificationPreferenceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserNotificationPreferencePayload>[]
        }
        create: {
          args: Prisma.UserNotificationPreferenceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserNotificationPreferencePayload>
        }
        createMany: {
          args: Prisma.UserNotificationPreferenceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserNotificationPreferenceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserNotificationPreferencePayload>[]
        }
        delete: {
          args: Prisma.UserNotificationPreferenceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserNotificationPreferencePayload>
        }
        update: {
          args: Prisma.UserNotificationPreferenceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserNotificationPreferencePayload>
        }
        deleteMany: {
          args: Prisma.UserNotificationPreferenceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserNotificationPreferenceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserNotificationPreferenceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserNotificationPreferencePayload>[]
        }
        upsert: {
          args: Prisma.UserNotificationPreferenceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserNotificationPreferencePayload>
        }
        aggregate: {
          args: Prisma.UserNotificationPreferenceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserNotificationPreference>
        }
        groupBy: {
          args: Prisma.UserNotificationPreferenceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserNotificationPreferenceGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserNotificationPreferenceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserNotificationPreferenceCountAggregateOutputType> | number
        }
      }
    }
  }
} & {
  other: {
    payload: any
    operations: {
      $executeRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $executeRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
      $queryRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $queryRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
    }
  }
}

/**
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
} as const)

export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


export const AppointmentScalarFieldEnum = {
  id: 'id',
  customerId: 'customerId',
  petId: 'petId',
  startAt: 'startAt',
  status: 'status',
  cancellationReason: 'cancellationReason',
  noShowReason: 'noShowReason',
  deletedAt: 'deletedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  notified24h: 'notified24h',
  notified1h: 'notified1h',
  category: 'category',
  seqId: 'seqId',
  performerId: 'performerId',
  pickupProviderId: 'pickupProviderId',
  dropoffProviderId: 'dropoffProviderId',
  quoteId: 'quoteId',
  logisticsStatus: 'logisticsStatus',
  logisticsLastRemindedAt: 'logisticsLastRemindedAt',
  recurringPackageId: 'recurringPackageId'
} as const

export type AppointmentScalarFieldEnum = (typeof AppointmentScalarFieldEnum)[keyof typeof AppointmentScalarFieldEnum]


export const RelationLoadStrategy = {
  query: 'query',
  join: 'join'
} as const

export type RelationLoadStrategy = (typeof RelationLoadStrategy)[keyof typeof RelationLoadStrategy]


export const AppreciationScalarFieldEnum = {
  id: 'id',
  badgeType: 'badgeType',
  senderId: 'senderId',
  receiverId: 'receiverId',
  comment: 'comment',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AppreciationScalarFieldEnum = (typeof AppreciationScalarFieldEnum)[keyof typeof AppreciationScalarFieldEnum]


export const AttendanceRecordScalarFieldEnum = {
  id: 'id',
  staffId: 'staffId',
  date: 'date',
  checkInAt: 'checkInAt',
  checkOutAt: 'checkOutAt',
  status: 'status',
  notes: 'notes',
  createdById: 'createdById',
  updatedById: 'updatedById',
  updateReason: 'updateReason',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AttendanceRecordScalarFieldEnum = (typeof AttendanceRecordScalarFieldEnum)[keyof typeof AttendanceRecordScalarFieldEnum]


export const AuditEventScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  actorUserId: 'actorUserId',
  actorNameSnapshot: 'actorNameSnapshot',
  actorRoleSnapshot: 'actorRoleSnapshot',
  source: 'source',
  ip: 'ip',
  userAgent: 'userAgent',
  requestId: 'requestId',
  targetType: 'targetType',
  targetId: 'targetId',
  clientId: 'clientId',
  appointmentId: 'appointmentId',
  quoteId: 'quoteId',
  petId: 'petId',
  action: 'action',
  severity: 'severity',
  summary: 'summary',
  meta: 'meta',
  before: 'before',
  after: 'after',
  diff: 'diff',
  revertible: 'revertible',
  revertStrategy: 'revertStrategy',
  revertedAt: 'revertedAt',
  revertedByUserId: 'revertedByUserId',
  revertReason: 'revertReason',
  revertOfEventId: 'revertOfEventId'
} as const

export type AuditEventScalarFieldEnum = (typeof AuditEventScalarFieldEnum)[keyof typeof AuditEventScalarFieldEnum]


export const AuditLogScalarFieldEnum = {
  id: 'id',
  entityType: 'entityType',
  entityId: 'entityId',
  action: 'action',
  performedBy: 'performedBy',
  previousData: 'previousData',
  newData: 'newData',
  createdAt: 'createdAt',
  reason: 'reason'
} as const

export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


export const AuthenticatorScalarFieldEnum = {
  id: 'id',
  credentialID: 'credentialID',
  credentialPublicKey: 'credentialPublicKey',
  counter: 'counter',
  credentialDeviceType: 'credentialDeviceType',
  credentialBackedUp: 'credentialBackedUp',
  transports: 'transports',
  userId: 'userId'
} as const

export type AuthenticatorScalarFieldEnum = (typeof AuthenticatorScalarFieldEnum)[keyof typeof AuthenticatorScalarFieldEnum]


export const BugReportScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  name: 'name',
  description: 'description',
  imageUrl: 'imageUrl',
  status: 'status',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  resolvedAt: 'resolvedAt'
} as const

export type BugReportScalarFieldEnum = (typeof BugReportScalarFieldEnum)[keyof typeof BugReportScalarFieldEnum]


export const CommentScalarFieldEnum = {
  id: 'id',
  content: 'content',
  authorId: 'authorId',
  postId: 'postId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt'
} as const

export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


export const ConversationScalarFieldEnum = {
  id: 'id',
  type: 'type',
  name: 'name',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  lastMessageAt: 'lastMessageAt'
} as const

export type ConversationScalarFieldEnum = (typeof ConversationScalarFieldEnum)[keyof typeof ConversationScalarFieldEnum]


export const CustomerScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  name: 'name',
  phone: 'phone',
  address: 'address',
  noShowCount: 'noShowCount',
  isBlocked: 'isBlocked',
  requiresPrepayment: 'requiresPrepayment',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  type: 'type',
  recurringFrequency: 'recurringFrequency',
  discountPercentage: 'discountPercentage',
  internalNotes: 'internalNotes',
  balance: 'balance',
  secondaryGuardianAddress: 'secondaryGuardianAddress',
  secondaryGuardianEmail: 'secondaryGuardianEmail',
  secondaryGuardianName: 'secondaryGuardianName',
  secondaryGuardianPhone: 'secondaryGuardianPhone',
  additionalGuardians: 'additionalGuardians',
  communicationOther: 'communicationOther',
  communicationPrefs: 'communicationPrefs',
  discoverySource: 'discoverySource',
  recurrenceDiscount: 'recurrenceDiscount',
  recurrenceFrequency: 'recurrenceFrequency',
  deletedAt: 'deletedAt',
  canRequestQuotes: 'canRequestQuotes',
  riskLevel: 'riskLevel',
  billingOther: 'billingOther',
  billingPreference: 'billingPreference',
  cpf: 'cpf',
  discoverySourceDetail: 'discoverySourceDetail',
  isActive: 'isActive',
  legacyBitrixId: 'legacyBitrixId',
  legacyCreatedAt: 'legacyCreatedAt',
  legacySource: 'legacySource',
  negotiationDiscount: 'negotiationDiscount',
  paymentMethod: 'paymentMethod',
  secondaryGuardianBirthday: 'secondaryGuardianBirthday'
} as const

export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


export const CustomerAlertScalarFieldEnum = {
  id: 'id',
  customerId: 'customerId',
  type: 'type',
  title: 'title',
  message: 'message',
  isActive: 'isActive',
  resolvedAt: 'resolvedAt',
  resolvedBy: 'resolvedBy',
  createdBy: 'createdBy',
  createdAt: 'createdAt'
} as const

export type CustomerAlertScalarFieldEnum = (typeof CustomerAlertScalarFieldEnum)[keyof typeof CustomerAlertScalarFieldEnum]


export const DebitCreditNoteScalarFieldEnum = {
  id: 'id',
  customerId: 'customerId',
  appointmentId: 'appointmentId',
  packageId: 'packageId',
  type: 'type',
  amount: 'amount',
  description: 'description',
  status: 'status',
  billingAction: 'billingAction',
  createdAt: 'createdAt',
  notes: 'notes'
} as const

export type DebitCreditNoteScalarFieldEnum = (typeof DebitCreditNoteScalarFieldEnum)[keyof typeof DebitCreditNoteScalarFieldEnum]


export const FinancialTransactionScalarFieldEnum = {
  id: 'id',
  customerId: 'customerId',
  type: 'type',
  amount: 'amount',
  description: 'description',
  category: 'category',
  relatedQuoteId: 'relatedQuoteId',
  relatedInvoiceId: 'relatedInvoiceId',
  createdBy: 'createdBy',
  createdAt: 'createdAt',
  notes: 'notes'
} as const

export type FinancialTransactionScalarFieldEnum = (typeof FinancialTransactionScalarFieldEnum)[keyof typeof FinancialTransactionScalarFieldEnum]


export const GoalScalarFieldEnum = {
  id: 'id',
  title: 'title',
  description: 'description',
  targetValue: 'targetValue',
  currentValue: 'currentValue',
  initialValue: 'initialValue',
  unit: 'unit',
  startDate: 'startDate',
  endDate: 'endDate',
  status: 'status',
  category: 'category',
  department: 'department',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  createdBy: 'createdBy'
} as const

export type GoalScalarFieldEnum = (typeof GoalScalarFieldEnum)[keyof typeof GoalScalarFieldEnum]


export const GoalAssignmentScalarFieldEnum = {
  id: 'id',
  goalId: 'goalId',
  staffId: 'staffId'
} as const

export type GoalAssignmentScalarFieldEnum = (typeof GoalAssignmentScalarFieldEnum)[keyof typeof GoalAssignmentScalarFieldEnum]


export const HrAuditLogScalarFieldEnum = {
  id: 'id',
  actorUserId: 'actorUserId',
  action: 'action',
  entityType: 'entityType',
  entityId: 'entityId',
  metaJson: 'metaJson',
  createdAt: 'createdAt'
} as const

export type HrAuditLogScalarFieldEnum = (typeof HrAuditLogScalarFieldEnum)[keyof typeof HrAuditLogScalarFieldEnum]


export const InvoiceScalarFieldEnum = {
  id: 'id',
  customerId: 'customerId',
  appointmentId: 'appointmentId',
  amount: 'amount',
  status: 'status',
  dueDate: 'dueDate',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt'
} as const

export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


export const MessageScalarFieldEnum = {
  id: 'id',
  content: 'content',
  senderId: 'senderId',
  conversationId: 'conversationId',
  createdAt: 'createdAt',
  readBy: 'readBy',
  fileUrl: 'fileUrl',
  fileType: 'fileType',
  fileName: 'fileName'
} as const

export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


export const MetricScalarFieldEnum = {
  id: 'id',
  type: 'type',
  data: 'data',
  timestamp: 'timestamp'
} as const

export type MetricScalarFieldEnum = (typeof MetricScalarFieldEnum)[keyof typeof MetricScalarFieldEnum]


export const NotificationScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  title: 'title',
  message: 'message',
  type: 'type',
  read: 'read',
  createdAt: 'createdAt',
  metadata: 'metadata',
  priority: 'priority',
  relatedId: 'relatedId',
  resolved: 'resolved',
  resolvedAt: 'resolvedAt',
  resolvedBy: 'resolvedBy'
} as const

export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


export const NotificationExecutionScalarFieldEnum = {
  id: 'id',
  scheduledNotificationId: 'scheduledNotificationId',
  executedAt: 'executedAt',
  recipientCount: 'recipientCount',
  successCount: 'successCount',
  failureCount: 'failureCount',
  metadata: 'metadata'
} as const

export type NotificationExecutionScalarFieldEnum = (typeof NotificationExecutionScalarFieldEnum)[keyof typeof NotificationExecutionScalarFieldEnum]


export const NotificationSettingsScalarFieldEnum = {
  id: 'id',
  notificationType: 'notificationType',
  enabled: 'enabled',
  frequency: 'frequency',
  allowedRoles: 'allowedRoles',
  minInterval: 'minInterval',
  updatedAt: 'updatedAt',
  updatedBy: 'updatedBy'
} as const

export type NotificationSettingsScalarFieldEnum = (typeof NotificationSettingsScalarFieldEnum)[keyof typeof NotificationSettingsScalarFieldEnum]


export const PackageItemScalarFieldEnum = {
  id: 'id',
  packageId: 'packageId',
  serviceId: 'serviceId',
  description: 'description',
  unitPrice: 'unitPrice',
  quantity: 'quantity',
  discount: 'discount',
  finalPrice: 'finalPrice'
} as const

export type PackageItemScalarFieldEnum = (typeof PackageItemScalarFieldEnum)[keyof typeof PackageItemScalarFieldEnum]


export const ParticipantScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  conversationId: 'conversationId',
  joinedAt: 'joinedAt',
  lastReadAt: 'lastReadAt'
} as const

export type ParticipantScalarFieldEnum = (typeof ParticipantScalarFieldEnum)[keyof typeof ParticipantScalarFieldEnum]


export const PayAdjustmentScalarFieldEnum = {
  id: 'id',
  payPeriodId: 'payPeriodId',
  staffId: 'staffId',
  type: 'type',
  amount: 'amount',
  direction: 'direction',
  reason: 'reason',
  createdById: 'createdById',
  createdAt: 'createdAt'
} as const

export type PayAdjustmentScalarFieldEnum = (typeof PayAdjustmentScalarFieldEnum)[keyof typeof PayAdjustmentScalarFieldEnum]


export const PayPeriodScalarFieldEnum = {
  id: 'id',
  startDate: 'startDate',
  endDate: 'endDate',
  type: 'type',
  status: 'status',
  createdById: 'createdById',
  closedById: 'closedById',
  closedAt: 'closedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PayPeriodScalarFieldEnum = (typeof PayPeriodScalarFieldEnum)[keyof typeof PayPeriodScalarFieldEnum]


export const PayStatementScalarFieldEnum = {
  id: 'id',
  payPeriodId: 'payPeriodId',
  staffId: 'staffId',
  baseTotal: 'baseTotal',
  adjustmentsTotal: 'adjustmentsTotal',
  totalDue: 'totalDue',
  detailsJson: 'detailsJson',
  generatedAt: 'generatedAt'
} as const

export type PayStatementScalarFieldEnum = (typeof PayStatementScalarFieldEnum)[keyof typeof PayStatementScalarFieldEnum]


export const PaymentRecordScalarFieldEnum = {
  id: 'id',
  invoiceId: 'invoiceId',
  amount: 'amount',
  paidAt: 'paidAt',
  method: 'method',
  createdAt: 'createdAt'
} as const

export type PaymentRecordScalarFieldEnum = (typeof PaymentRecordScalarFieldEnum)[keyof typeof PaymentRecordScalarFieldEnum]


export const PetScalarFieldEnum = {
  id: 'id',
  customerId: 'customerId',
  name: 'name',
  species: 'species',
  breed: 'breed',
  weight: 'weight',
  observations: 'observations',
  preferences: 'preferences',
  coatType: 'coatType',
  usesPerfume: 'usesPerfume',
  usesOrnaments: 'usesOrnaments',
  marketingConsent: 'marketingConsent',
  temperament: 'temperament',
  firstTime: 'firstTime',
  age: 'age',
  healthIssues: 'healthIssues',
  allergies: 'allergies',
  hasKnots: 'hasKnots',
  hasMattedFur: 'hasMattedFur',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  usedToGrooming: 'usedToGrooming',
  groomingAdapter: 'groomingAdapter',
  groomingHeight: 'groomingHeight',
  groomingMachine: 'groomingMachine',
  groomingNotes: 'groomingNotes',
  groomingScissors: 'groomingScissors',
  allowsTreats: 'allowsTreats',
  authorityCommand: 'authorityCommand',
  birthDate: 'birthDate',
  favoriteToy: 'favoriteToy',
  feedingType: 'feedingType',
  habits: 'habits',
  handlingPreference: 'handlingPreference',
  hasOwnTrousseau: 'hasOwnTrousseau',
  hasSpecialNeeds: 'hasSpecialNeeds',
  isCastrated: 'isCastrated',
  knowsHotelOrDaycare: 'knowsHotelOrDaycare',
  medicationAllergies: 'medicationAllergies',
  medicationDetails: 'medicationDetails',
  nightHabits: 'nightHabits',
  parasiteControlUpToDate: 'parasiteControlUpToDate',
  photoUrl: 'photoUrl',
  relationshipOrigin: 'relationshipOrigin',
  sex: 'sex',
  size: 'size',
  socialWithAnimals: 'socialWithAnimals',
  socialWithHumans: 'socialWithHumans',
  specialNeedsDescription: 'specialNeedsDescription',
  takesMedication: 'takesMedication',
  timeWithPet: 'timeWithPet',
  usedToBeingAway: 'usedToBeingAway',
  vaccinesUpToDate: 'vaccinesUpToDate',
  walkingFrequency: 'walkingFrequency'
} as const

export type PetScalarFieldEnum = (typeof PetScalarFieldEnum)[keyof typeof PetScalarFieldEnum]


export const PostScalarFieldEnum = {
  id: 'id',
  content: 'content',
  authorId: 'authorId',
  attachments: 'attachments',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt'
} as const

export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


export const ProductScalarFieldEnum = {
  id: 'id',
  seqId: 'seqId',
  name: 'name',
  description: 'description',
  price: 'price',
  stock: 'stock',
  category: 'category',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt'
} as const

export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


export const PushSubscriptionScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  endpoint: 'endpoint',
  p256dh: 'p256dh',
  auth: 'auth',
  createdAt: 'createdAt'
} as const

export type PushSubscriptionScalarFieldEnum = (typeof PushSubscriptionScalarFieldEnum)[keyof typeof PushSubscriptionScalarFieldEnum]


export const QuoteScalarFieldEnum = {
  id: 'id',
  customerId: 'customerId',
  petId: 'petId',
  status: 'status',
  totalAmount: 'totalAmount',
  desiredAt: 'desiredAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt',
  transportDestination: 'transportDestination',
  transportOrigin: 'transportOrigin',
  transportPeriod: 'transportPeriod',
  type: 'type',
  hairLength: 'hairLength',
  hasKnots: 'hasKnots',
  hasParasites: 'hasParasites',
  knotRegions: 'knotRegions',
  petQuantity: 'petQuantity',
  transportReturnAddress: 'transportReturnAddress',
  seqId: 'seqId',
  scheduledAt: 'scheduledAt',
  transportAt: 'transportAt',
  invoiceId: 'invoiceId',
  parasiteComments: 'parasiteComments',
  parasiteTypes: 'parasiteTypes',
  wantsMedicatedBath: 'wantsMedicatedBath',
  transportType: 'transportType',
  transportLevaAt: 'transportLevaAt',
  transportTrazAt: 'transportTrazAt',
  notes: 'notes',
  isRecurring: 'isRecurring',
  frequency: 'frequency',
  packageDiscount: 'packageDiscount',
  cardFeePercent: 'cardFeePercent',
  taxPercent: 'taxPercent',
  recurringPackageId: 'recurringPackageId',
  transportPlan: 'transportPlan',
  transportMode: 'transportMode',
  transportStopAddress: 'transportStopAddress',
  transportDiscountPercent: 'transportDiscountPercent',
  transportTotalBefore: 'transportTotalBefore',
  transportTotalAfter: 'transportTotalAfter',
  transportLevaTotalBefore: 'transportLevaTotalBefore',
  transportLevaTotalAfter: 'transportLevaTotalAfter',
  transportTrazTotalBefore: 'transportTrazTotalBefore',
  transportTrazTotalAfter: 'transportTrazTotalAfter'
} as const

export type QuoteScalarFieldEnum = (typeof QuoteScalarFieldEnum)[keyof typeof QuoteScalarFieldEnum]


export const QuoteItemScalarFieldEnum = {
  id: 'id',
  quoteId: 'quoteId',
  description: 'description',
  quantity: 'quantity',
  price: 'price',
  serviceId: 'serviceId',
  performerId: 'performerId',
  discount: 'discount',
  productId: 'productId'
} as const

export type QuoteItemScalarFieldEnum = (typeof QuoteItemScalarFieldEnum)[keyof typeof QuoteItemScalarFieldEnum]


export const ReactionScalarFieldEnum = {
  id: 'id',
  type: 'type',
  authorId: 'authorId',
  postId: 'postId',
  createdAt: 'createdAt'
} as const

export type ReactionScalarFieldEnum = (typeof ReactionScalarFieldEnum)[keyof typeof ReactionScalarFieldEnum]


export const RecurringPackageScalarFieldEnum = {
  id: 'id',
  customerId: 'customerId',
  petId: 'petId',
  frequency: 'frequency',
  discountPercent: 'discountPercent',
  transportDiscount: 'transportDiscount',
  monthlyTotal: 'monthlyTotal',
  status: 'status',
  startDate: 'startDate',
  endDate: 'endDate',
  billingType: 'billingType',
  notes: 'notes',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type RecurringPackageScalarFieldEnum = (typeof RecurringPackageScalarFieldEnum)[keyof typeof RecurringPackageScalarFieldEnum]


export const RolePermissionScalarFieldEnum = {
  role: 'role',
  permissions: 'permissions',
  updatedAt: 'updatedAt',
  label: 'label'
} as const

export type RolePermissionScalarFieldEnum = (typeof RolePermissionScalarFieldEnum)[keyof typeof RolePermissionScalarFieldEnum]


export const ScheduledNotificationScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  scheduleType: 'scheduleType',
  cronExpression: 'cronExpression',
  intervalMinutes: 'intervalMinutes',
  scheduledAt: 'scheduledAt',
  timezone: 'timezone',
  targetType: 'targetType',
  targetRoles: 'targetRoles',
  targetUserIds: 'targetUserIds',
  title: 'title',
  body: 'body',
  notificationType: 'notificationType',
  conditions: 'conditions',
  enabled: 'enabled',
  priority: 'priority',
  lastExecutedAt: 'lastExecutedAt',
  nextExecutionAt: 'nextExecutionAt',
  executionCount: 'executionCount',
  failureCount: 'failureCount',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  createdBy: 'createdBy'
} as const

export type ScheduledNotificationScalarFieldEnum = (typeof ScheduledNotificationScalarFieldEnum)[keyof typeof ScheduledNotificationScalarFieldEnum]


export const ServiceScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  basePrice: 'basePrice',
  duration: 'duration',
  category: 'category',
  species: 'species',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  maxWeight: 'maxWeight',
  minWeight: 'minWeight',
  sizeLabel: 'sizeLabel',
  responsibleId: 'responsibleId',
  seqId: 'seqId',
  deletedAt: 'deletedAt',
  subcategory: 'subcategory',
  type: 'type',
  coatType: 'coatType',
  unit: 'unit',
  notes: 'notes',
  bathCategory: 'bathCategory',
  groomingType: 'groomingType'
} as const

export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


export const ServiceExecutionScalarFieldEnum = {
  id: 'id',
  appointmentId: 'appointmentId',
  staffId: 'staffId',
  serviceId: 'serviceId',
  executedAt: 'executedAt',
  notes: 'notes',
  createdAt: 'createdAt'
} as const

export type ServiceExecutionScalarFieldEnum = (typeof ServiceExecutionScalarFieldEnum)[keyof typeof ServiceExecutionScalarFieldEnum]


export const StaffProfileScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  department: 'department',
  payModel: 'payModel',
  dailyRate: 'dailyRate',
  perLegRate: 'perLegRate',
  payPeriodPreference: 'payPeriodPreference',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  mealVoucher: 'mealVoucher',
  otherBenefits: 'otherBenefits',
  transportVoucher: 'transportVoucher',
  bankAccount: 'bankAccount',
  bankAgency: 'bankAgency',
  bankName: 'bankName',
  companyName: 'companyName',
  documentNumber: 'documentNumber',
  documentType: 'documentType',
  employmentType: 'employmentType',
  notes: 'notes',
  pixKey: 'pixKey',
  address: 'address',
  birthday: 'birthday',
  cnhCategory: 'cnhCategory',
  cnhEar: 'cnhEar',
  cnhExpiry: 'cnhExpiry',
  cnhNumber: 'cnhNumber',
  emergencyContactName: 'emergencyContactName',
  emergencyContactPhone: 'emergencyContactPhone',
  emergencyContactRelation: 'emergencyContactRelation',
  hiringDate: 'hiringDate'
} as const

export type StaffProfileScalarFieldEnum = (typeof StaffProfileScalarFieldEnum)[keyof typeof StaffProfileScalarFieldEnum]


export const StatusHistoryScalarFieldEnum = {
  id: 'id',
  appointmentId: 'appointmentId',
  quoteId: 'quoteId',
  oldStatus: 'oldStatus',
  newStatus: 'newStatus',
  changedBy: 'changedBy',
  reason: 'reason',
  createdAt: 'createdAt'
} as const

export type StatusHistoryScalarFieldEnum = (typeof StatusHistoryScalarFieldEnum)[keyof typeof StatusHistoryScalarFieldEnum]


export const TransportDetailsScalarFieldEnum = {
  id: 'id',
  appointmentId: 'appointmentId',
  origin: 'origin',
  destination: 'destination',
  requestedPeriod: 'requestedPeriod',
  confirmedTime: 'confirmedTime',
  status: 'status',
  type: 'type',
  startedAt: 'startedAt',
  completedAt: 'completedAt'
} as const

export type TransportDetailsScalarFieldEnum = (typeof TransportDetailsScalarFieldEnum)[keyof typeof TransportDetailsScalarFieldEnum]


export const TransportLegExecutionScalarFieldEnum = {
  id: 'id',
  appointmentId: 'appointmentId',
  staffId: 'staffId',
  legType: 'legType',
  completedAt: 'completedAt',
  legValue: 'legValue',
  notes: 'notes',
  createdAt: 'createdAt'
} as const

export type TransportLegExecutionScalarFieldEnum = (typeof TransportLegExecutionScalarFieldEnum)[keyof typeof TransportLegExecutionScalarFieldEnum]


export const TransportLegScalarFieldEnum = {
  id: 'id',
  quoteId: 'quoteId',
  kind: 'kind',
  originAddress: 'originAddress',
  destinationAddress: 'destinationAddress',
  distanceKm: 'distanceKm',
  durationMin: 'durationMin',
  chargeKm: 'chargeKm',
  chargeMin: 'chargeMin',
  kmRate: 'kmRate',
  minRate: 'minRate',
  subtotal: 'subtotal',
  assignedProviderId: 'assignedProviderId',
  createdAt: 'createdAt'
} as const

export type TransportLegScalarFieldEnum = (typeof TransportLegScalarFieldEnum)[keyof typeof TransportLegScalarFieldEnum]


export const RouteCacheScalarFieldEnum = {
  id: 'id',
  routeKey: 'routeKey',
  originAddress: 'originAddress',
  destinationAddress: 'destinationAddress',
  stopAddress: 'stopAddress',
  distanceKm: 'distanceKm',
  durationMin: 'durationMin',
  cachedAt: 'cachedAt',
  expiresAt: 'expiresAt'
} as const

export type RouteCacheScalarFieldEnum = (typeof RouteCacheScalarFieldEnum)[keyof typeof RouteCacheScalarFieldEnum]


export const TransportSettingsScalarFieldEnum = {
  id: 'id',
  handlingTimeLeva: 'handlingTimeLeva',
  handlingTimeTraz: 'handlingTimeTraz',
  updatedAt: 'updatedAt',
  kmPriceLargada: 'kmPriceLargada',
  kmPriceLeva: 'kmPriceLeva',
  kmPriceTraz: 'kmPriceTraz',
  kmPriceRetorno: 'kmPriceRetorno',
  minPriceLargada: 'minPriceLargada',
  minPriceLeva: 'minPriceLeva',
  minPriceTraz: 'minPriceTraz',
  minPriceRetorno: 'minPriceRetorno',
  handlingTimeLargada: 'handlingTimeLargada',
  handlingTimeRetorno: 'handlingTimeRetorno',
  kmRate: 'kmRate',
  minRate: 'minRate',
  taxPercent: 'taxPercent',
  providerSharePercent: 'providerSharePercent'
} as const

export type TransportSettingsScalarFieldEnum = (typeof TransportSettingsScalarFieldEnum)[keyof typeof TransportSettingsScalarFieldEnum]


export const UserScalarFieldEnum = {
  id: 'id',
  email: 'email',
  passwordHash: 'passwordHash',
  googleId: 'googleId',
  name: 'name',
  phone: 'phone',
  document: 'document',
  address: 'address',
  birthday: 'birthday',
  admissionDate: 'admissionDate',
  notes: 'notes',
  permissions: 'permissions',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt',
  extraAddresses: 'extraAddresses',
  extraEmails: 'extraEmails',
  extraPhones: 'extraPhones',
  firstName: 'firstName',
  lastName: 'lastName',
  seqId: 'seqId',
  staffId: 'staffId',
  showTutorial: 'showTutorial',
  color: 'color',
  role: 'role',
  plainPassword: 'plainPassword',
  division: 'division',
  isEligible: 'isEligible',
  active: 'active',
  isSupportAgent: 'isSupportAgent',
  allowedGames: 'allowedGames',
  pauseMenuEnabled: 'pauseMenuEnabled'
} as const

export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


export const UserNotificationPreferenceScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  notificationType: 'notificationType',
  enabled: 'enabled',
  channels: 'channels',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type UserNotificationPreferenceScalarFieldEnum = (typeof UserNotificationPreferenceScalarFieldEnum)[keyof typeof UserNotificationPreferenceScalarFieldEnum]


export const SortOrder = {
  asc: 'asc',
  desc: 'desc'
} as const

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


export const NullableJsonNullValueInput = {
  DbNull: DbNull,
  JsonNull: JsonNull
} as const

export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


export const JsonNullValueInput = {
  JsonNull: JsonNull
} as const

export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


export const QueryMode = {
  default: 'default',
  insensitive: 'insensitive'
} as const

export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


export const NullsOrder = {
  first: 'first',
  last: 'last'
} as const

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


export const JsonNullValueFilter = {
  DbNull: DbNull,
  JsonNull: JsonNull,
  AnyNull: AnyNull
} as const

export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]



/**
 * Field references
 */


/**
 * Reference to a field of type 'String'
 */
export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


/**
 * Reference to a field of type 'String[]'
 */
export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


/**
 * Reference to a field of type 'DateTime'
 */
export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


/**
 * Reference to a field of type 'DateTime[]'
 */
export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


/**
 * Reference to a field of type 'AppointmentStatus'
 */
export type EnumAppointmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentStatus'>
    


/**
 * Reference to a field of type 'AppointmentStatus[]'
 */
export type ListEnumAppointmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentStatus[]'>
    


/**
 * Reference to a field of type 'Boolean'
 */
export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


/**
 * Reference to a field of type 'AppointmentCategory'
 */
export type EnumAppointmentCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentCategory'>
    


/**
 * Reference to a field of type 'AppointmentCategory[]'
 */
export type ListEnumAppointmentCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentCategory[]'>
    


/**
 * Reference to a field of type 'Int'
 */
export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


/**
 * Reference to a field of type 'Int[]'
 */
export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


/**
 * Reference to a field of type 'AuditSource'
 */
export type EnumAuditSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditSource'>
    


/**
 * Reference to a field of type 'AuditSource[]'
 */
export type ListEnumAuditSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditSource[]'>
    


/**
 * Reference to a field of type 'AuditTargetType'
 */
export type EnumAuditTargetTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditTargetType'>
    


/**
 * Reference to a field of type 'AuditTargetType[]'
 */
export type ListEnumAuditTargetTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditTargetType[]'>
    


/**
 * Reference to a field of type 'AuditAction'
 */
export type EnumAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditAction'>
    


/**
 * Reference to a field of type 'AuditAction[]'
 */
export type ListEnumAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditAction[]'>
    


/**
 * Reference to a field of type 'AuditSeverity'
 */
export type EnumAuditSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditSeverity'>
    


/**
 * Reference to a field of type 'AuditSeverity[]'
 */
export type ListEnumAuditSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditSeverity[]'>
    


/**
 * Reference to a field of type 'Json'
 */
export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


/**
 * Reference to a field of type 'QueryMode'
 */
export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


/**
 * Reference to a field of type 'Bytes'
 */
export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


/**
 * Reference to a field of type 'Bytes[]'
 */
export type ListBytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes[]'>
    


/**
 * Reference to a field of type 'BigInt'
 */
export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


/**
 * Reference to a field of type 'BigInt[]'
 */
export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


/**
 * Reference to a field of type 'Float'
 */
export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


/**
 * Reference to a field of type 'Float[]'
 */
export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


/**
 * Reference to a field of type 'DebitCreditType'
 */
export type EnumDebitCreditTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DebitCreditType'>
    


/**
 * Reference to a field of type 'DebitCreditType[]'
 */
export type ListEnumDebitCreditTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DebitCreditType[]'>
    


/**
 * Reference to a field of type 'DebitCreditStatus'
 */
export type EnumDebitCreditStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DebitCreditStatus'>
    


/**
 * Reference to a field of type 'DebitCreditStatus[]'
 */
export type ListEnumDebitCreditStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DebitCreditStatus[]'>
    


/**
 * Reference to a field of type 'BillingAction'
 */
export type EnumBillingActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillingAction'>
    


/**
 * Reference to a field of type 'BillingAction[]'
 */
export type ListEnumBillingActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillingAction[]'>
    


/**
 * Reference to a field of type 'InvoiceStatus'
 */
export type EnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus'>
    


/**
 * Reference to a field of type 'InvoiceStatus[]'
 */
export type ListEnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus[]'>
    


/**
 * Reference to a field of type 'QuoteStatus'
 */
export type EnumQuoteStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuoteStatus'>
    


/**
 * Reference to a field of type 'QuoteStatus[]'
 */
export type ListEnumQuoteStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuoteStatus[]'>
    


/**
 * Reference to a field of type 'TransportPeriod'
 */
export type EnumTransportPeriodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransportPeriod'>
    


/**
 * Reference to a field of type 'TransportPeriod[]'
 */
export type ListEnumTransportPeriodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransportPeriod[]'>
    


/**
 * Reference to a field of type 'QuoteType'
 */
export type EnumQuoteTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuoteType'>
    


/**
 * Reference to a field of type 'QuoteType[]'
 */
export type ListEnumQuoteTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuoteType[]'>
    


/**
 * Reference to a field of type 'TransportType'
 */
export type EnumTransportTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransportType'>
    


/**
 * Reference to a field of type 'TransportType[]'
 */
export type ListEnumTransportTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransportType[]'>
    


/**
 * Reference to a field of type 'PackageFrequency'
 */
export type EnumPackageFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PackageFrequency'>
    


/**
 * Reference to a field of type 'PackageFrequency[]'
 */
export type ListEnumPackageFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PackageFrequency[]'>
    


/**
 * Reference to a field of type 'PackageStatus'
 */
export type EnumPackageStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PackageStatus'>
    


/**
 * Reference to a field of type 'PackageStatus[]'
 */
export type ListEnumPackageStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PackageStatus[]'>
    


/**
 * Reference to a field of type 'BillingType'
 */
export type EnumBillingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillingType'>
    


/**
 * Reference to a field of type 'BillingType[]'
 */
export type ListEnumBillingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillingType[]'>
    

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
export type BatchPayload = {
  count: number
}

export const defineExtension = runtime.Extensions.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<"define", TypeMapCb, runtime.Types.Extensions.DefaultArgs>
export type DefaultPrismaClient = PrismaClient
export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
export type PrismaClientOptions = ({
  /**
   * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-pg`.
   */
  adapter: runtime.SqlDriverAdapterFactory
  accelerateUrl?: never
} | {
  /**
   * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
   */
  accelerateUrl: string
  adapter?: never
}) & {
  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat
  /**
   * @example
   * ```
   * // Shorthand for `emit: 'stdout'`
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events only
   * log: [
   *   { emit: 'event', level: 'query' },
   *   { emit: 'event', level: 'info' },
   *   { emit: 'event', level: 'warn' }
   *   { emit: 'event', level: 'error' }
   * ]
   * 
   * / Emit as events and log to stdout
   * og: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * 
   * ```
   * Read more in our [docs](https://pris.ly/d/logging).
   */
  log?: (LogLevel | LogDefinition)[]
  /**
   * The default values for transactionOptions
   * maxWait ?= 2000
   * timeout ?= 5000
   */
  transactionOptions?: {
    maxWait?: number
    timeout?: number
    isolationLevel?: TransactionIsolationLevel
  }
  /**
   * Global configuration for omitting model fields by default.
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   omit: {
   *     user: {
   *       password: true
   *     }
   *   }
   * })
   * ```
   */
  omit?: GlobalOmitConfig
  /**
   * SQL commenter plugins that add metadata to SQL queries as comments.
   * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   adapter,
   *   comments: [
   *     traceContext(),
   *     queryInsights(),
   *   ],
   * })
   * ```
   */
  comments?: runtime.SqlCommenterPlugin[]
}
export type GlobalOmitConfig = {
  appointment?: Prisma.AppointmentOmit
  appreciation?: Prisma.AppreciationOmit
  attendanceRecord?: Prisma.AttendanceRecordOmit
  auditEvent?: Prisma.AuditEventOmit
  auditLog?: Prisma.AuditLogOmit
  authenticator?: Prisma.AuthenticatorOmit
  bugReport?: Prisma.BugReportOmit
  comment?: Prisma.CommentOmit
  conversation?: Prisma.ConversationOmit
  customer?: Prisma.CustomerOmit
  customerAlert?: Prisma.CustomerAlertOmit
  debitCreditNote?: Prisma.DebitCreditNoteOmit
  financialTransaction?: Prisma.FinancialTransactionOmit
  goal?: Prisma.GoalOmit
  goalAssignment?: Prisma.GoalAssignmentOmit
  hrAuditLog?: Prisma.HrAuditLogOmit
  invoice?: Prisma.InvoiceOmit
  message?: Prisma.MessageOmit
  metric?: Prisma.MetricOmit
  notification?: Prisma.NotificationOmit
  notificationExecution?: Prisma.NotificationExecutionOmit
  notificationSettings?: Prisma.NotificationSettingsOmit
  packageItem?: Prisma.PackageItemOmit
  participant?: Prisma.ParticipantOmit
  payAdjustment?: Prisma.PayAdjustmentOmit
  payPeriod?: Prisma.PayPeriodOmit
  payStatement?: Prisma.PayStatementOmit
  paymentRecord?: Prisma.PaymentRecordOmit
  pet?: Prisma.PetOmit
  post?: Prisma.PostOmit
  product?: Prisma.ProductOmit
  pushSubscription?: Prisma.PushSubscriptionOmit
  quote?: Prisma.QuoteOmit
  quoteItem?: Prisma.QuoteItemOmit
  reaction?: Prisma.ReactionOmit
  recurringPackage?: Prisma.RecurringPackageOmit
  rolePermission?: Prisma.RolePermissionOmit
  scheduledNotification?: Prisma.ScheduledNotificationOmit
  service?: Prisma.ServiceOmit
  serviceExecution?: Prisma.ServiceExecutionOmit
  staffProfile?: Prisma.StaffProfileOmit
  statusHistory?: Prisma.StatusHistoryOmit
  transportDetails?: Prisma.TransportDetailsOmit
  transportLegExecution?: Prisma.TransportLegExecutionOmit
  transportLeg?: Prisma.TransportLegOmit
  routeCache?: Prisma.RouteCacheOmit
  transportSettings?: Prisma.TransportSettingsOmit
  user?: Prisma.UserOmit
  userNotificationPreference?: Prisma.UserNotificationPreferenceOmit
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

export type GetLogType<T> = CheckIsLogLevel<
  T extends LogDefinition ? T['level'] : T
>;

export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
  ? GetLogType<T[number]>
  : never;

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type PrismaAction =
  | 'findUnique'
  | 'findUniqueOrThrow'
  | 'findMany'
  | 'findFirst'
  | 'findFirstOrThrow'
  | 'create'
  | 'createMany'
  | 'createManyAndReturn'
  | 'update'
  | 'updateMany'
  | 'updateManyAndReturn'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'
  | 'count'
  | 'runCommandRaw'
  | 'findRaw'
  | 'groupBy'

/**
 * `PrismaClient` proxy available in interactive transactions.
 */
export type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>

